[{"content":"개요 JPA를 사용한 일정 관리 앱을 개발하던 중에 발생한 문제이다.\n필터를 통해 세션에 정보가 있는지 여부로 로그인 여부를 판별하고 있다.\n트러블 슈팅 배경 필터를 통해 세션에 정보가 있는지 여부로 로그인 여부를 판별하고 있다.\n로그인이 안된 상태로 로그인 필수 path 에 접근시 예외를 던지게 해두었다.\n그리고 해당 예외는 RestControllerAdvice 를 통해 예외를 처리하도록 해두었다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class LoginFilter implements Filter { private static final String[] PUBLIC_PATH_LIST = {\u0026#34;/users/register\u0026#34;, \u0026#34;/users/login\u0026#34;}; @Override public void doFilter( ServletRequest request, ServletResponse response, FilterChain filterChain ) throws IOException, ServletException { HttpServletRequest req = (HttpServletRequest) request; HttpServletResponse res = (HttpServletResponse) response; String requestURI = req.getRequestURI(); boolean isPrivatePath = !PatternMatchUtils.simpleMatch(PUBLIC_PATH_LIST, requestURI); if (isPrivatePath) { HttpSession session = req.getSession(); if (session == null || session.getAttribute(\u0026#34;userId\u0026#34;) == null) { throw new RuntimeException(\u0026#34;Please login first\u0026#34;); } } filterChain.doFilter(request, response); } } 발단 개요와 같이 적용하고 실제로 로그인이 안된 상태에서 로그인 필수 path 에 접근하면 공통 예외 처리가 동작할 줄 알았다. 하지만 RestControllerAdvice 를 통해 공통으로 예외를 처리해둔 곳이 기능하지 않는다.\n전개 이런 문제가 발생하는 이유는 RestControllerAdvice 는 컨트롤러에서 발생한 예외를 잡을 순 있지만, 컨트롤러에 도달하기 전 필터에서 발생한 예외는 잡을 수 없기 때문이다.\n이를 해결하기 위해 예외를 던지는 것이 아닌 응답에 예외를 바로 담도록 수정하였다.\n결말 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 public class LoginFilter implements Filter { private static final String[] PUBLIC_PATH_LIST = {\u0026#34;/users/register\u0026#34;, \u0026#34;/users/login\u0026#34;}; @Override public void doFilter( ServletRequest request, ServletResponse response, FilterChain filterChain ) throws IOException, ServletException { HttpServletRequest req = (HttpServletRequest) request; HttpServletResponse res = (HttpServletResponse) response; String requestURI = req.getRequestURI(); boolean isPrivatePath = !PatternMatchUtils.simpleMatch(PUBLIC_PATH_LIST, requestURI); if (isPrivatePath) { HttpSession session = req.getSession(); if (session == null || session.getAttribute(\u0026#34;userId\u0026#34;) == null) { exceptionHandler(requestURI, res); return; } } filterChain.doFilter(request, response); } private void exceptionHandler(String requestURI, HttpServletResponse res) { res.setStatus(HttpStatus.UNAUTHORIZED.value()); res.setContentType(\u0026#34;application/json\u0026#34;); res.setCharacterEncoding(\u0026#34;UTF-8\u0026#34;); try { ObjectMapper objectMapper = new ObjectMapper(); objectMapper.registerModule(new JavaTimeModule()); String json = objectMapper.writeValueAsString( ErrorResponse.of( HttpStatus.UNAUTHORIZED, \u0026#34;Please log in and try again.\u0026#34;, requestURI) ); res.getWriter().write(json); } catch (Exception e) { log.error(\u0026#34;LoginFilter - exceptionHandler {}\u0026#34;, e.getMessage()); } } } 최종적으로 위와 같은 코드를 작성하였다.\n로그인이 안된 상태에서 로그인 필수 path 에 접근해보면 정상적으로 공통 오류 메시지가 응답되는 것을 확인할 수 있다.\n마무리 이번 트러블 슈팅을 요약하면 다음과 같습니다.\n웹 애플리케이션을 작업하다 보면 필터에서 예외를 처리해야하는 경우가 생깁니다. 스프링 시큐리티를 사용할 경우 처리할 수 있는 방법이 따로 있습니다. 하지만 이번 경우에는 스프링 시큐리티를 사용하지 않기 때문에 다른 방법으로 해결해야 합니다. 이번 경우에는 필터에서 예외를 던지는 것이 아닌 응답에 바로 예외 공통 메시지를 넣음으로써 해결이 되었습니다. ","date":"2025-03-27T00:00:00Z","permalink":"https://dungbik.github.io/p/til-3/","title":"Spring Filter 에서 예외 발생시 RestControllerAdvice 로 처리 안됨"},{"content":"개요 일정 관리 앱을 개발하던 중에 발생한 문제이다.\n일정을 조회하는데 사용자 정보까지 필요한 상황이다.\n트러블 슈팅 배경 현재 일정 엔티티에는 사용자의 정보는 없고 사용자의 id 필드만 가지고 있다.\n발단 일정을 조회했을 때 id 뿐만이 아닌 사용자의 다른 정보들도 응답에 넣어주려고 한다.\n현재는 일정을 조회했을 때 사용자에 관한 정보는 사용자의 id만 알 수 있는 상태이다.\n전개 이를 해결하기 위해서는 두가지의 방법이 있을 것 같다.\nJOIN 을 통해 한번의 조회문으로 사용자의 id가 일치하는 사용자의 정보를 같이 조회한다. 일정을 조회하고 사용자의 id로 사용자 정보를 한번 더 조회해서 병합한다. 결말 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 /** * 검색 쿼리를 동적으로 생성 * @param cond 검색 조건 * @return 검색을 수행하는 쿼리문 */ private String createSearchQuery(ScheduleSearchCond cond) { String sql = \u0026#34;SELECT DISTINCT s.id, u.email, u.name, s.task, s.created_at, s.updated_at FROM schedule s JOIN user u ON u.id = s.user_id\u0026#34;; if (StringUtils.hasText(cond.getUsername())) { sql += \u0026#34; AND u.name like concat(\u0026#39;%\u0026#39;, :username, \u0026#39;%\u0026#39;)\u0026#34;; } if (cond.getUpdatedAt() != null) { sql += \u0026#34; WHERE DATE(s.updated_at) = :updatedAt\u0026#34;; } if (cond.getUserId() != null) { sql += \u0026#34; AND s.user_id = :userId\u0026#34;; } sql += \u0026#34; ORDER BY s.updated_at DESC LIMIT :limit OFFSET :offset\u0026#34;; return sql; } /** * 작성자 정보를 포함한 일정 정보를 만드는 Mapper * @return 작성자 정보를 포함한 일정 정보를 만드는 Mapper */ private RowMapper\u0026lt;ScheduleResponse\u0026gt; scheduleResponseRowMapper() { return ((rs, rowNum) -\u0026gt; { ScheduleResponse response = new ScheduleResponse(); response.setScheduleId(rs.getLong(\u0026#34;s.id\u0026#34;)); response.setUser(new UserResponse(rs.getLong(\u0026#34;u.id\u0026#34;), rs.getString(\u0026#34;u.email\u0026#34;), rs.getString(\u0026#34;u.name\u0026#34;))); response.setTask(rs.getString(\u0026#34;s.task\u0026#34;)); response.setCreatedAt(rs.getTimestamp(\u0026#34;s.created_at\u0026#34;).toLocalDateTime()); response.setUpdatedAt(rs.getTimestamp(\u0026#34;s.updated_at\u0026#34;).toLocalDateTime()); return response; }); } 최종적으로 위와 같은 코드를 작성하였다.\nJOIN 을 통해 사용자의 정보까지 같이 조회한 후 사용자의 정보를 포함한 일정 정보를 얻을 수 있도록 하였다.\n마무리 이번 트러블 슈팅을 요약하면 다음과 같습니다.\n웹 애플리케이션을 작업하다 보면 다수의 엔티티를 병합하여 사용해야 하는 경우가 생깁니다. 이 때 우리가 생각할 수 있는 방법에는 JOIN 활용 혹은 따로 조회 후 병합 등 여러가지 방법이 있을 수 있습니다. 이번 경우에는 2번 호출하는 것 보단 1번의 호출로 조회할 수 있는 것이 좋을 것 같아 JOIN 을 활용하였습니다. ","date":"2025-03-20T00:00:00Z","permalink":"https://dungbik.github.io/p/til-2/","title":"엔티티에 없는 정보까지 필요한 경우의 고민"},{"content":"\n비즈니스 로직을 담은 애플리케이션 핵심 코드와 엔터프라이즈 기술을 처리하는 코드를 분리시킨다.\n각각의 복잡함을 효과적으로 공략하기 위해 POJO와 함께 스프링 3대 핵심 기술을 사용한다.\n이 전략이 효과적으로 적용되려면 반드시 좋은 객체 지향 설계가 바탕이 되어야 한다.\nPlain Old Java Object (POJO) 객체 지향적 원리에 충실하고 특정 규약과 환경에 종속되지 않게 재활용될 수 있는 방식으로 설계된 객체\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import javax.jms.MessageListener; import javax.jms.Message; import javax.jms.JMSException; public class OrderProcesser implements MessageListener { @Override public void onMessage(Message message) { if (message instanceof TextMessage) { try { OrderPlaced event = OrderPlaced.fromJson(((TextMessage) message).getText()); // 주문 접수 처리하기 } catch (JMSException error) { throw new RuntimeException(\u0026#34;The message could not be read.\u0026#34;, error); } } else { throw new IllegalArgumentException(\u0026#34;Message must be of type TextMessage\u0026#34;); } } } 저수준의 기술과 환경에 종속적인 코드와 비즈니스 로직이 섞여 있어서 읽고 이해하기도 어려우며, 검증이나 테스트 작성에도 어려움이 있으므로 유지 보수에 어려움이 있다.\n1 2 3 4 5 6 7 8 9 import org.springframework.jms.annotation.JmsListener; public class OrderProcesser { @JmsListener(destination = \u0026#34;pos\u0026#34;) public void accept(OrderPlaced event) { // 주문 접수 처리하기 } } Inversion Of Control (IoC) 프로그램 제어 흐름 구조가 뒤바뀌는 것\n다른 객체를 직접 생성하거나 제어하는 것이 아니라 외부에서 관리하는 객체를 가져와 사용하는 것\n스프링에선 외부에서 객체를 관리하는 것은 스프링 컨테이너, 관리되는 객체를 빈 이라고 함\n필요한 이유\n객체지향 원칙을 잘 지키기 위해 역할과 관심을 분리하여 응집도는 높이고 결합도는 낮추며, 변경에 유연한 코드를 작성할 수 있는 구조로 만들 수 있기 때문 Dependency Injection (DI) 의존 관계에 있는 오브젝트를 직접 생성하는 게 아닌 외부에서 생성 후 주입 시켜주는 방식\n모듈 간의 결합도가 낮아지고 유연성이 높아짐\n스프링 IoC 기능의 대표적인 동작 원리\n의존 관계 주입 방법 설명 constructor 생성자를 통해 의존 관계를 주입한다. setter setter 메서드를 통해 의존 관계를 주입한다. field 스프링에서 @autowired 어노테이션이 붙은 필드에 의존 관계룰 주입한다. 생성자 주입이 선호된다\n객체의 불변성 확보 의존 관계 주입이 생성자 호출시 최초 1회만 이루어지기 때문에 불변성을 확보 가능 NullPointerException 방지 의존 관계가 설정되지 않으면 컴파일 타임에 알 수 있음 순환 참조 방지 순환 참조 감지 기능을 제공 테스트 코드 작성에 용이 Aspect Oriented Programming (AOP) 횡단 관심사(cross-cutting concern)의 분리를 허용함으로써 모듈성을 증가시키는 것이 목적인 프로그래밍 패러다임\n횡단 관심사(cross-cutting concern)\n소프트웨어 개발에서 핵심 기능 이외의 공통적인 로직이나 기능 여러 모듈 또는 객체에서 반복적으로 나타나며, 여러 부분에 걸쳐 퍼져 있는 경우가 많음 횡단 관심사를 모듈화하여 코드의 중복을 줄이고 유지 보수를 쉽게 해줌\n스프링 AOP\nProxy를 기반으로 한 Runtime Weaving 방식이다 Runtime Weaving: 런타임시 target 객체를 새로운 프록시 객체로 적용시키는 과정 스프링 Bean에만 적용할 수 있으며 모든 AOP 기능을 제공하는 것이 목적이 아닌 중복 코드, 프록시 클래스 작성의 번거로움 등의 문제를 해결하기 위한 솔루션을 제공하는 것 Dynmic Proxy Interface를 기반으로 Proxy 생성 Reflection 사용 기본 생성 전략 CGLIB Proxy 바이트코드 생성 기술을 이용해 상속 기반으로 Proxy 생성 final 객체 혹은 private 접근자로 된 메서드는 상속이 지원되지 않기 때문에 사용 불가 성능이 좀 더 우세 Portable Service Abstraction (PSA) 환경과 변화와 관계없이 일관된 방식의 기술로의 접근 환경을 제공하는 추상화 구조\n엔터프라이즈 애플리케이션에 사용되는 다양한 기술의 서비스 추상화가 제공됨\n대표적으로 트랜잭션, 캐시, 메일, 메시징 OXM (Object/XML Mapping) 등이 있다. 제어의 역전 (Inversion Of Control; IoC) 원리를 통해 POJO에게 제공됨\n","date":"2025-03-18T00:00:00Z","permalink":"https://dungbik.github.io/p/til-1/","title":"복잡함을 다루기 위한 스프링의 전략"},{"content":"ch.2 키오스크 과제 트러블 슈팅 개요 키오스크는 전에 수행했던 과제와 다르게 단계가 나누어져 있다.\n카테고리 선택 단계, 메뉴 선택 단계 등 여러 개의 단계로 이루어져 있는데, 현재 단계가 무슨 단계인지 알 수 있는 것이 필요했다.\n트러블 슈팅 배경 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 private int curStage = 0; public void start() { while (curStage \u0026lt; 7) { switch (curStage) { case 0 -\u0026gt; { ... } case 1 -\u0026gt; { ... } case 2 -\u0026gt; { ... } case 3 -\u0026gt; { ... } } } } public void order() { ... // 주문이 끝나서 카테고리 선택 기능으로 돌아가야함 curStage = 0; } 발단 배경의 코드와 같이 현재 상태를 숫자로서 나타내게 코드를 작성을 하였다.\n현재 단계를 이동시킬 때, 숫자로 구분을 하니 다른 기능 단계를 실수로 적어 기능이 이상하게 구현되는 문제가 있었다.\n예를 들면, 주문이 끝난 후 카테고리 선택 기능으로 돌아가야 하는데 메뉴 선택을 하는 기능으로 동작되는 이런 오류들이 발생하였다.\n전개 1 2 3 4 private static final int SELECT_CATEGORY = 0; ... private static final int EXIT = 7; 이를 해결하기 위해 처음에 생각한 방법은 상수로써 관리를 하는 것이였다.\n이렇게 상수로 관리를 하니 전에 같이 실수를 하는 일은 없었다. 하지만 실시간 강의 때, 해당 상수들이 집합으로써 묶이는 경우에는 Enum 을 사용하는 것도 좋은 방법이라고 들어서 이를 이용하여 코드를 구현하였다.\n결말 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /** * 키오스크 시스템의 메인 실행 루프를 시작합니다. * 이 메서드는 현재 단계와 사용자 상호작용에 따라 키오스크 운영의 다양한 단계를 지속적으로 전환합니다. * \u0026lt;p\u0026gt; * 이 메서드는 상태 변화를 관리하고 키오스크 워크플로우와 관련된 특정 작업을 호출합니다: * - SELECT_CATEGORY: 사용자가 카테고리를 선택할 수 있도록 지원합니다. * - SELECT_MENU_ITEM: 선택된 카테고리 내에서 메뉴 항목 선택을 처리합니다. * - CONFIRM_ADD_TO_CART: 선택된 항목을 장바구니에 추가할지 사용자 확인을 요청합니다. * - ADD_TO_CART: 선택된 항목을 장바구니에 추가합니다. * - CONFIRM_ORDER: 주문을 진행할지 사용자 확인을 요청합니다. * - CANCEL_ORDER: 진행 중인 주문을 취소하고 필요한 상태를 재설정합니다. * - REMOVE_CART_ITEM: 사용자가 장바구니에서 항목을 제거할 수 있도록 합니다. * - SELECT_BENEFIT: 사용자가 주문을 완료하기 전에 적용 가능한 혜택을 선택할 수 있도록 합니다. * - ORDER: 주문을 확정하고, 할인을 적용하며, 거래를 완료합니다. * \u0026lt;p\u0026gt; * 현재 단계가 Stage.EXIT로 전환되면 메서드는 종료됩니다. */ public void start() { while (curStage != Stage.EXIT) { switch (curStage) { case SELECT_CATEGORY -\u0026gt; selectCategory(); case SELECT_MENU_ITEM -\u0026gt; selectMenuItem(); case CONFIRM_ADD_TO_CART -\u0026gt; confirmAddToCart(); case ADD_TO_CART -\u0026gt; addToCart(); case CONFIRM_ORDER -\u0026gt; confirmOrder(); case CANCEL_ORDER -\u0026gt; cancelOrder(); case REMOVE_CART_ITEM -\u0026gt; removeCartItem(); case SELECT_BENEFIT -\u0026gt; selectBenefit(); case ORDER -\u0026gt; order(); } } } 최종적으로 위와 같은 코드를 작성하였다.\n마무리 이번 트러블 슈팅을 요약하면 다음과 같습니다.\n코드를 작성하다보면 상태 혹은 단계, 종류 등을 저장하고 사용해야할 때가 있습니다. 이 때 단순히 문자열이나 숫자로 사용하는 것은 매우 안좋은 방법입니다. 가독성이 떨어지고 실수가 많이 생김 이럴 때는 상수 혹은 Enum 을 사용하는 것이 방법이 될 수 있습니다. 집합이 가능하다면 Enum, 외의 경우에는 상수 ","date":"2025-03-07T00:00:00Z","permalink":"https://dungbik.github.io/p/nb-til-14/","title":"내일배움캠프 - 14일차"},{"content":"스트림 처리, 배치 처리 스트림 처리 단순한 구조입력 데이터가 들어오는 즉시 처리할 수 있다. 데이터 스트림이 지속적으로 업데이트된다. 다양한 데이터 소스와 통합 가능하며, 실시간 분석에 적합하다. 실시간 데이터를 처리하는 시스템은 설정과 유지 관리가 복잡할 수 있다. 초당 많은 이벤트를 처리해야 하므로 시스템 리소스 요구량이 높을 수 있다. 실시간 데이터 분석은 배치 처리와 달리 결과의 완정성을 보장하기 어렵다. 배치 처리 고정된 데이터셋을 처리하므로 구현이 상대적으로 간단하다. 전체 데이터를 한 번에 분석할 수 있어 복잡한 연산을 수행하기 적합하다. 대량의 데이터를 처리하도록 확장 가능하며, 빅데이터 플랫폼과의 통합이 용이하다. 데이터 처리가 끝나기 전까지 결과를 확인할 수 없다. 대량 데이터를 처리하는 동안 시간이 많이 소요될 수 있다. 고정된 데이터셋을 사용하기 떄문에, 실시간으로 데이터가 변경되는 환경에는 적합하지 않다. 기술 비교 기술 배치 처리 스트림 처리 특징 Spring Batch ✅ ❌ - 배치 처리 특화 프레임워크\n- 데이터 처리 파이프라인 정의 및 실행 간소화\n- Java 기반으로 사용 용이\n- 실시간 처리 기능 부족\n- 병렬성과 확장성이 제한적 Apache Flink ✅ ✅ - 실시간 스트림 처리에 최적화\n- 상태 기반 처리(Stateful Processing)\n- 높은 확장성과 분산 처리 가능\n- 초기 학습 곡선이 가파르며, 설정이 복잡\n- 자원 소비가 높은 편 Apache Spark ✅ ✅ - 배치와 스트림 처리 모두 지원\n- 마이크로 배치(Micro-Batch) 기반 스트림 처리\n- 대규모 병렬 처리에 유리\n- 다양한 언어 지원\n- Flink에 비해 스트림 처리에서 지연 시간이 길 수 있음 ","date":"2025-03-05T00:00:00Z","permalink":"https://dungbik.github.io/p/nb-til-12/","title":"내일배움캠프 - 12일차"},{"content":"코드카타 나 잡아 봐라 Q. 연인 코니와 브라운은 광활한 들판에서 ‘나 잡아 봐라’ 게임을 한다.\n이 게임은 브라운이 코니를 잡거나, 코니가 너무 멀리 달아나면 끝난다.\n게임이 끝나는데 걸리는 최소 시간을 구하시오.\n조건은 다음과 같다.\n코니는 처음 위치 C에서 1초 후 1만큼 움직이고,\n이후에는 가속이 붙어 매 초마다 이전 이동 거리 + 1만큼 움직인다.\n즉 시간에 따른 코니의 위치는 C, C + 1, C + 3, C + 6, …이다.\n브라운은 현재 위치 B에서 다음 순간 B – 1, B + 1, 2 * B 중 하나로 움직일 수 있다.\n코니와 브라운의 위치 p는 조건 0 \u0026lt;= x \u0026lt;= 200,000을 만족한다.\n브라운은 범위를 벗어나는 위치로는 이동할 수 없고, 코니가 범위를 벗어나면 게임이 끝난다\n게임이 종료되는데 걸리는 최소 시간을 구하려면 모든 경우의 수를 확인해봐야한다. 이 문제의 경우 최소 시간을 구해야하기 떄문에 DFS 를 사용하기로 결정했다.\n그리고 잡았는지 여부는 같은 시간에 같은 위치에 있는 것이기 떄문에 시간에 따른 위치를 기록해야한다. 따라서 key를 위치, value를 도달한 시간 집합 형태를 가지는 딕셔너리를 사용했다. 여기서 딕셔너리와 집합을 이용한 이유는 데이터에 접근이 효율적이기 떄문이다.\n그 외에 신경쓸 것은 2가지가 더 있다.\n하나는 위치가 200000 보다 클 경우 잡지못한 채로 게임이 끝난 부분을 처리해주는 것이다.\n또 하나는 1초마다 움직이는 것이기 때문에 큐를 while queue: 가 아닌 for i in range(len(queue)): 를 사용한 것이다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 from collections import deque def catch_me(cony_loc, brown_loc): time = 0 queue = deque() queue.append((brown_loc, 0)) visited = [{} for _ in range(200001)] while cony_loc \u0026lt; 200000: cony_loc += time if time in visited[cony_loc]: return time for i in range(len(queue)): cur_loc, cur_time = queue.popleft() next_loc = cur_loc - 1 next_time = cur_time + 1 if next_loc \u0026gt;= 0 and next_time not in visited[next_loc]: visited[next_loc][next_time] = True queue.append((next_loc, next_time)) next_loc = cur_loc + 1 if next_loc \u0026lt;= 200000 and next_time not in visited[next_loc]: visited[next_loc][next_time] = True queue.append((next_loc, next_time)) next_loc = cur_loc * 2 if next_loc \u0026lt;= 200000 and next_time not in visited[next_loc]: visited[next_loc][next_time] = True queue.append((next_loc, next_time)) time += 1 print(\u0026#34;정답 = 3 / 현재 풀이 값 = \u0026#34;, catch_me(10,3)) print(\u0026#34;정답 = 8 / 현재 풀이 값 = \u0026#34;, catch_me(51,50)) print(\u0026#34;정답 = 28 / 현재 풀이 값 = \u0026#34;, catch_me(550,500)) 외부 API 호출 외부 API를 호출이 필요하게 되어 예전에 개발할 때 자주 썼던 HttpClient로 코드를 작성하였다.\n되게 간단한 API를 호출하는데 코드가 복잡하고 가독성이 좋지 않았다.\n사용하기 편한 형태로 커스텀 메서드를 만들어서 사용할 수 있었으나, 더 좋은 대안이 있지 않을까 하고 찾아보았다.\n많은 대안이 있었는데 그 중에서 많이 검색되는 몇 가지 방법만 정리해보았다.\nFeignClient 인터페이스와 애노테이션으로 간단하게 사용 가능 Spring Cloud와 잘 통합되며, 마이크로서비스 환경에서 많이 사용 동기 호출만 가능 WebClient (Spring WebFlux) 비동기 및 논블로킹 HTTP 클라이언트 Mono와 Flux를 사용해 반응형 프로그래밍을 지원 높은 성능과 확장성 반응형 프로그래밍에 익숙하지 않다면 학습 곡선이 존재 설정이 상대적으로 복잡 RestTemplate 사용법이 간단 Spring 5 이후로 deprecated 낮은 성능과 확장성 HttpClient (Apache) 세부적인 HTTP 요청을 컨트롤 가능 상대적으로 복잡한 코드 작성 필요 OkHttp 경량화된 HTTP 클라이언트 높은 성능과 간단한 사용법 비동기 요청을 간단히 처리 가능 Spring Boot에 사용시 추가 설정 필요 Retrofit OkHttp 위에 선언형 방식으로 동작함 Feign과 비슷한 스타일 Spring Boot에 사용시 추가 설정 필요 현재 상황에서 간단한 API 동기 호출만 필요하고 간단하게 사용할 수 있는 것이 중요하기 때문에에 FeignClient를 사용하기로 결정하였다.\n","date":"2025-02-28T00:00:00Z","permalink":"https://dungbik.github.io/p/nb-til-10/","title":"내일배움캠프 - 10일차"},{"content":"코드카타 라면 공장 Q. 라면 공장에서는 하루에 밀가루를 1톤씩 사용합니다. 원래 밀가루를 공급받던 공장의 고장으로 앞으로 k일 이후에야 밀가루를 공급받을 수 있기 때문에 해외 공장에서 밀가루를 수입해야 합니다.\n해외 공장에서는 향후 밀가루를 공급할 수 있는 날짜와 수량을 알려주었고, 라면 공장에서는 운송비를 줄이기 위해 최소한의 횟수로 밀가루를 공급받고 싶습니다.\n현재 공장에 남아있는 밀가루 수량 stock, 밀가루 공급 일정(dates)과 해당 시점에 공급 가능한 밀가루 수량(supplies), 원래 공장으로부터 공급받을 수 있는 시점 k가 주어질 때, 밀가루가 떨어지지 않고 공장을 운영하기 위해서 최소한 몇 번 해외 공장으로부터 밀가루를 공급받아야 하는지를 반환 하시오.\ndates[i]에는 i번째 공급 가능일이 들어있으며, supplies[i]에는 dates[i] 날짜에 공급 가능한 밀가루 수량이 들어 있습니다.\nstock = 4\ndates = [4, 10, 15]\nsupplies = [20, 5, 10]\nk = 30\n다음과 같이 입력값이 들어온다면,\n현재 재고가 4개 있습니다. 그리고 정상적으로 돌아오는 날은 30일까지입니다.\n즉, 26개의 공급량을 사와야 합니다!\n그러면 제일 최소한으로 26개를 가져오려면? supplies 에서 20, 10 을 가져오면 되겠죠?\n그래서 이 경우의 최소 공급 횟수는 2 입니다!\n최소로 공급을 받기 위해서는 제일 높은 공급량을 더해서 정상적으로 돌아오는 날까지 버틸 수 있으면 된다. 여기서 현재 재고가 바닥나기 전까지 공급을 받아야한다는 것을 빼먹으면 안된다.\n재고가 바닥나기 전에 받을 수 있는 최대 공급량을 찾을 때 정렬 혹은 Max Heap 등 방법이 여러가지 있는데 여기서는 Max Heap을 사용하였다. heapq 는 Min Heap 이기 때문에 넣는 값에 -를 붙여 Max Heap 으로 사용하였다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import heapq def get_minimum_count_of_overseas_supply(stock, dates, supplies, k): answer = 0 last_added_date_index = 0 max_heap = [] while stock \u0026lt;= k: while last_added_date_index \u0026lt; len(dates) and dates[last_added_date_index] \u0026lt;= stock: heapq.heappush(max_heap, -supplies[last_added_date_index]) last_added_date_index += 1 answer += 1 heappop = heapq.heappop(max_heap) stock += -heappop return answer print(\u0026#34;정답 = 2 / 현재 풀이 값 = \u0026#34;, get_minimum_count_of_overseas_supply(4, [4, 10, 15], [20, 5, 10], 30)) print(\u0026#34;정답 = 4 / 현재 풀이 값 = \u0026#34;, get_minimum_count_of_overseas_supply(4, [4, 10, 15, 20], [20, 5, 10, 5], 40)) print(\u0026#34;정답 = 1 / 현재 풀이 값 = \u0026#34;, get_minimum_count_of_overseas_supply(2, [1, 10], [10, 100], 11)) 로봇 청소기 문제 설명 로봇 청소기가 주어졌을 때, 청소하는 영역의 개수를 구하는 프로그램을 작성하시오.\n로봇 청소기가 있는 장소는 N×M 크기의 직사각형으로 나타낼 수 있으며, 1×1크기의 정사각형 칸으로 나누어져 있다. 각각의 칸은 벽 또는 빈 칸이다. 청소기는 바라보는 방향이 있으며, 이 방향은 동, 서, 남, 북중 하나이다. 지도의 각 칸은 (r, c)로 나타낼 수 있고, r은 북쪽으로부터 떨어진 칸의 개수, c는 서쪽으로 부터 떨어진 칸의 개수이다.\n로봇 청소기는 다음과 같이 작동한다.\n현재 위치를 청소한다. 현재 위치에서 현재 방향을 기준으로 왼쪽방향부터 차례대로 탐색을 진행한다.\na. 왼쪽 방향에 아직 청소하지 않은 공간이 존재한다면, 그 방향으로 회전한 다음 한 칸을 전진하고 1번부터 진행한다.\nb. 왼쪽 방향에 청소할 공간이 없다면, 그 방향으로 회전하고 2번으로 돌아간다.\nc. 네 방향 모두 청소가 이미 되어있거나 벽인 경우에는, 바라보는 방향을 유지한 채로 한 칸 후진을 하고 2번으로 돌아간다.\nd. 네 방향 모두 청소가 이미 되어있거나 벽이면서, 뒤쪽 방향이 벽이라 후진도 할 수 없는 경우에는 작동을 멈춘다. 로봇 청소기는 이미 청소되어있는 칸을 또 청소하지 않으며, 벽을 통과할 수 없다. 입력 조건 로봇 청소기가 있는 칸의 좌표 (r, c)와 바라보는 방향 d가 주어진다. 이 때 d가 0인 경우에는 북쪽을, 1인 경우에는 동쪽을, 2인 경우에는 남쪽을, 3인 경우에는 서쪽을 바라보고 있는 것이다.\n또한 청소하고자 하는 방의 지도를 2차원 배열로 주어진다. 빈 칸은 0, 벽은 1로 주어진다. 지도의 첫 행, 마지막 행, 첫 열, 마지막 열에 있는 모든 칸은 벽이다.\n로봇 청소기가 있는 칸의 상태는 항상 빈 칸이라고 했을 때, 로봇 청소기가 청소하는 칸의 개수를 반환하시오.\n왼쪽 방향으로 돌면서 탐색을 진행해야한다. 이를 위해서 방향부터 정의를 하였다.\nindex r c 북 0 -1 0 동 1 0 1 남 2 1 0 서 3 0 -1 이처럼 방향을 정의하면 (index + 3) % 4 을 왼쪽 방향이라고 할 수 있다.\n또한 후진을 해야하는데, (index + 2) % 4를 후진이라고 할 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 from collections import deque def get_count_of_departments_cleaned_by_robot_vacuum(r, c, d, room_map): dr = [-1, 0, 1, 0] dc = [0, 1, 0, -1] n = len(room_map) m = len(room_map[0]) result = 1 room_map[r][c] = 2 queue = deque([[r, c, d]]) while queue: r, c, d = queue.popleft() temp_d = d for i in range(4): temp_d = (temp_d + 3) % 4 new_r, new_c = r + dr[temp_d], c + dc[temp_d] if 0 \u0026lt;= new_r \u0026lt; n and 0 \u0026lt;= new_c \u0026lt; m and room_map[new_r][new_c] == 0: result += 1 room_map[new_r][new_c] = 2 queue.append([new_r, new_c, temp_d]) break elif i == 3: new_d = (d + 2) % 4 new_r, new_c = r + dr[new_d], c + dc[new_d] queue.append([new_r, new_c, d]) if room_map[new_r][new_c] == 1: return result current_room_map2 = [ [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 0, 1, 1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 1, 1, 1, 1, 0, 1], [1, 0, 0, 1, 1, 0, 0, 0, 0, 1], [1, 0, 1, 1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 0, 1, 0, 1], [1, 0, 0, 0, 0, 0, 1, 1, 0, 1], [1, 0, 0, 0, 0, 0, 1, 1, 0, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1] ] print(\u0026#34;정답 = 29 / 현재 풀이 값 = \u0026#34;, get_count_of_departments_cleaned_by_robot_vacuum(6,3,1,current_room_map2)) current_room_map3 = [ [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 0, 1, 1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 1, 1, 1, 1, 0, 1], [1, 0, 0, 1, 1, 0, 0, 0, 0, 1], [1, 0, 1, 1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 0, 1, 0, 1], [1, 0, 0, 0, 0, 0, 1, 1, 0, 1], [1, 0, 0, 1, 0, 0, 1, 1, 0, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1] ] print(\u0026#34;정답 = 33 / 현재 풀이 값 = \u0026#34;, get_count_of_departments_cleaned_by_robot_vacuum(7,4,1,current_room_map3)) current_room_map4 = [ [1, 1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 0, 1, 1, 0, 0, 0, 0, 0, 1], [1, 0, 1, 0, 1, 1, 1, 1, 0, 1], [1, 0, 0, 1, 1, 0, 0, 0, 0, 1], [1, 0, 1, 1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 0, 1, 0, 1], [1, 0, 0, 0, 0, 0, 1, 1, 0, 1], [1, 0, 0, 1, 0, 0, 1, 1, 0, 1], [1, 0, 0, 0, 0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1] ] print(\u0026#34;정답 = 25 / 현재 풀이 값 = \u0026#34;, get_count_of_departments_cleaned_by_robot_vacuum(6,2,0,current_room_map4)) 극장 좌석 Q. 극장의 좌석은 한 줄로 되어 있으며 왼쪽부터 차례대로 1번부터 N번까지 번호가 매겨져 있다.\n공연을 보러 온 사람들은 자기의 입장권에 표시되어 있는 좌석에 앉아야 한다.\n예를 들어서, 입장권에 5번이 쓰여 있으면 5번 좌석에 앉아야 한다.\n단, 자기의 바로 왼쪽 좌석 또는 바로 오른쪽 좌석으로는 자리를 옮길 수 있다.\n예를 들어서, 7번 입장권을 가진 사람은 7번 좌석은 물론이고,\n6번 좌석이나 8번 좌석에도 앉을 수 있다.\n그러나 5번 좌석이나 9번 좌석에는 앉을 수 없다.\n그런데 이 극장에는 “VIP 회원”들이 있다.\n이 사람들은 반드시 자기 좌석에만 앉아야 하며 옆 좌석으로 자리를 옮길 수 없다.\n예를 들어서,\n그림과 같이 좌석이 9개이고,\n4번 좌석과 7번 좌석이 VIP석인 경우에 \u0026lt;123456789\u0026gt;는 물론 가능한 배치이다.\n또한 \u0026lt;213465789\u0026gt; 와 \u0026lt;132465798\u0026gt; 도 가능한 배치이다.\n그러나 \u0026lt;312456789\u0026gt; 와 \u0026lt;123546789\u0026gt; 는 허용되지 않는 배치 방법이다.\n오늘 공연은 입장권이 매진되어 1번 좌석부터 N번 좌석까지 모든 좌석이 다 팔렸다.\n총 좌석의 개수와 VIP 회원들의 좌석 번호들이 주어졌을 때,\n사람들이 좌석에 앉는 서로 다른 방법의 가짓수를 반환하시오.\nseat_count = 9\nvip_seat_array = [4, 7]\nVIP석을 제외하고 자리를 옮길 수 있고, 옮기는 것은 옆 좌석으로만 가능하다. 그러면 좌석에 앉는 서로 다른 방법의 가짓수를 구하기 위해서는 VIP 석을 제외한 좌석에서 이동 가능한 경우의 수를 구하면 된다.\n이를 예시를 보며 알아내보자.\n[1] -\u0026gt; [1] [1, 2] -\u0026gt; [1, 2], [2, 1] [1, 2, 3] -\u0026gt; [1, 2, 3], [1, 3, 2], [2, 1, 3] [1, 2, 3, 4] -\u0026gt; [1, 2, 3, 4] [1, 2, 4, 3] [1, 3, 2, 4] [2, 1, 3, 4] [2, 1, 4, 3] [1, 2, 3, 4, 5] -\u0026gt; [1, 2, 3, 4, 5] [1, 2, 3, 5, 4] [2, 1, 3, 4, 5] [2, 1, 3, 5, 4], [1, 2, 4, 3, 5] [2, 1, 4, 3, 5] [2, 1, 3, 4, 5] [1, 3, 2, 4, 5] 이를 보면 1, 2, 3, 5, 8 \u0026hellip; 피보나치 수열처럼 증가하는 것을 알 수 있다.\n따라서 피보나치 수열을 이용해 유동석의 경우의 수들을 각각 구해 모두 곱해주면 모든 경우의 수란 것을 알 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 fibo_memo = { 0: 1, 1: 1, 2: 2 } def fibo_dynamic_programming(n): if n in fibo_memo: return fibo_memo[n] nth_fibo = fibo_dynamic_programming(n - 1) + fibo_dynamic_programming(n - 2) fibo_memo[n] = nth_fibo return nth_fibo def get_all_ways_of_theater_seat(total_count, fixed_seat_array): all_ways = 1 current_index = 0 for fixed_seat in fixed_seat_array: fixed_seat_index = fixed_seat - 1 count_of_ways = fibo_dynamic_programming(fixed_seat_index - current_index) all_ways *= count_of_ways current_index = fixed_seat_index + 1 count_of_ways = fibo_dynamic_programming(total_count - current_index) all_ways *= count_of_ways return all_ways print(\u0026#34;정답 = 4 / 현재 풀이 값 = \u0026#34;, get_all_ways_of_theater_seat(9,[2,4,7])) print(\u0026#34;정답 = 26 / 현재 풀이 값 = \u0026#34;, get_all_ways_of_theater_seat(11,[2,5])) print(\u0026#34;정답 = 6 / 현재 풀이 값 = \u0026#34;, get_all_ways_of_theater_seat(10,[2,6,9])) ","date":"2025-02-27T00:00:00Z","permalink":"https://dungbik.github.io/p/nb-til-9/","title":"내일배움캠프 - 9일차"},{"content":"코드카타 최대로 할인 적용하기 Q. 다음과 같이 숫자로 이루어진 배열이 두 개가 있다. 하나는 상품의 가격을 담은 배열이고, 하나는 쿠폰을 담은 배열이다. 쿠폰의 할인율에 따라 상품의 가격을 할인 받을 수 있다. 이 때, 최대한 할인을 많이 받는다면 얼마를 내야 하는가? 단, 할인쿠폰은 한 제품에 한 번씩만 적용 가능하다.\n[30000, 2000, 1500000] # 상품의 가격\n[20, 40] # 쿠폰, 할인율의 단위는 % 입니다.\n가장 할인을 많이 받기 위해선 상품의 가격이 비싼 순으로 할인율이 높은 쿠폰을 적용하면 된다.\n그리고 상품의 수와 쿠폰의 가격이 같지 않기 때문에 할인을 적용할 때는 상품의 수 혹은 쿠폰 수 하나를 지정해놓고 반복을 하면 안되고 둘 중에 작은 숫자만큼 반복을 수행해야한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def get_max_discounted_price(prices, coupons): coupons.sort(reverse=True) prices.sort(reverse=True) price_index = 0 coupon_index = 0 max_discounted_price = 0 while price_index \u0026lt; len(prices) and coupon_index \u0026lt; len(coupons): max_discounted_price += prices[price_index] * (100 - coupons[coupon_index]) / 100 price_index += 1 coupon_index += 1 while price_index \u0026lt; len(prices): max_discounted_price += prices[price_index] price_index += 1 return int(max_discounted_price) print(\u0026#34;정답 = 926000 / 현재 풀이 값 = \u0026#34;, get_max_discounted_price([30000, 2000, 1500000], [20, 40])) print(\u0026#34;정답 = 485000 / 현재 풀이 값 = \u0026#34;, get_max_discounted_price([50000, 1500000], [10, 70, 30, 20])) print(\u0026#34;정답 = 1550000 / 현재 풀이 값 = \u0026#34;, get_max_discounted_price([50000, 1500000], [])) print(\u0026#34;정답 = 1458000 / 현재 풀이 값 = \u0026#34;, get_max_discounted_price([20000, 100000, 1500000], [10, 10, 10])) 올바른 괄호 Q. 괄호가 바르게 짝지어졌다는 것은 \u0026lsquo;(\u0026rsquo; 문자로 열렸으면 반드시 짝지어서 \u0026lsquo;)\u0026rsquo; 문자로 닫혀야 한다는 뜻이다. 예를 들어\n()() 또는 (())() 는 올바르다. )()( 또는 (()( 는 올바르지 않다.\n이 때, \u0026lsquo;(\u0026rsquo; 또는 \u0026lsquo;)\u0026rsquo; 로만 이루어진 문자열 s가 주어졌을 때, 문자열 s가 올바른 괄호이면 True 를 반환하고 아니라면 False 를 반환하시오.\n괄호가 바르게 짝지어졌는지 확인을 하기 위해서는 닫는 괄호가 나왔을 때, 직전에 나왔던 괄호가 열려있는지 확인해야한다.\n즉, 배열로 생각했을 때 열린 괄호가 나오면 모두 저장하고 닫힌 괄호가 나왔을 때 가장 최근에 있던 열린 괄호를 삭제 하는 것을 반복하여 마지막에 배열이 비어있는지 여부를 확인하면 된다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def is_correct_parenthesis(string): stack = [] for i in range(len(string)): if string[i] == \u0026#34;(\u0026#34;: stack.append(string[i]) elif string[i] == \u0026#34;)\u0026#34;: if len(stack) == 0: return False stack.pop() if len(stack) != 0: return False else: return True print(\u0026#34;정답 = True / 현재 풀이 값 = \u0026#34;, is_correct_parenthesis(\u0026#34;(())\u0026#34;)) print(\u0026#34;정답 = False / 현재 풀이 값 = \u0026#34;, is_correct_parenthesis(\u0026#34;)\u0026#34;)) print(\u0026#34;정답 = False / 현재 풀이 값 = \u0026#34;, is_correct_parenthesis(\u0026#34;((())))\u0026#34;)) print(\u0026#34;정답 = False / 현재 풀이 값 = \u0026#34;, is_correct_parenthesis(\u0026#34;())()\u0026#34;)) print(\u0026#34;정답 = False / 현재 풀이 값 = \u0026#34;, is_correct_parenthesis(\u0026#34;((())\u0026#34;)) 멜론 베스트 앨범 뽑기 Q. 멜론에서 장르 별로 가장 많이 재생된 노래를 두 개씩 모아 베스트 앨범을 출시하려 한다.\n노래는 인덱스로 구분하며, 노래를 수록하는 기준은 다음과 같다.\n속한 노래가 많이 재생된 장르를 먼저 수록한다. (단, 각 장르에 속한 노래의 재생 수 총합은 모두 다르다.)\n장르 내에서 많이 재생된 노래를 먼저 수록한다.\n장르 내에서 재생 횟수가 같은 노래 중에서는 고유 번호가 낮은 노래를 먼저 수록한다.\n노래의 장르를 나타내는 문자열 배열 genres와 노래별 재생 횟수를 나타내는 정수 배열 plays가 주어질 때, 베스트 앨범에 들어갈 노래의 인덱스를 순서대로 반환하시오.\n각 장르에 속한 노래의 재생 수를 더하여 정렬을 하면 1번의 결과를 알 수 있다. 이를 쉽게 하기 위해선 딕셔너리를 활용해 key를 장르 value를 재생 수의 합으로 하면 된다.\n그리고 2번의 결과를 알기 위해 딕셔너리를 활용해 key를 장르 value를 노래 고유 번호와 재생 수를 배열의 형태로 배열에 담는다.\n그 후 value에 들어 있는 배열에서 재생 수를 기준으로 정렬을 하면 된다.\n여기서 고유 번호가 낮은 노래의 처리를 하지 않은 이유는 정렬을 할 때 기준이 같다면 순서가 변하지 않기 떄문이다.\n마지막 3번의 결과는 지금까지 구한 결과를 토대로 알 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from collections import defaultdict def get_total_play(songs): return sum([x[1] for x in songs]) def get_melon_best_album(genre_array, play_array): music_dict = defaultdict(list) song_id = 0 for genre, play in zip(genres, plays): music_dict[genre].append((song_id, play)) song_id += 1 sorted_music_dict = sorted(music_dict.items(), key=lambda x: get_total_play(x[1]), reverse=True) answer = [] for _, songs in sorted_music_dict: sorted_songs = sorted(songs, key=lambda x: x[1], reverse=True) answer.extend([x[0] for x in sorted_songs[0: min(len(songs), 2)]]) return answer print(\u0026#34;정답 = [4, 1, 3, 0] / 현재 풀이 값 = \u0026#34;, get_melon_best_album([\u0026#34;classic\u0026#34;, \u0026#34;pop\u0026#34;, \u0026#34;classic\u0026#34;, \u0026#34;classic\u0026#34;, \u0026#34;pop\u0026#34;], [500, 600, 150, 800, 2500])) print(\u0026#34;정답 = [0, 6, 5, 2, 4, 1] / 현재 풀이 값 = \u0026#34;, get_melon_best_album([\u0026#34;hiphop\u0026#34;, \u0026#34;classic\u0026#34;, \u0026#34;pop\u0026#34;, \u0026#34;classic\u0026#34;, \u0026#34;classic\u0026#34;, \u0026#34;pop\u0026#34;, \u0026#34;hiphop\u0026#34;], [2000, 500, 600, 150, 800, 2500, 2000])) 모니터링 모니터링 3단계 대시보드 전체를 한눈에 볼 수 있는 가장 높은 뷰 마이크로미터, 프로메테우스, 그라파나 등 모니터링 대상 시스템 메트릭 애플리케이션 메트릭 비즈니스 메트릭 애플리케이션 추적 주로 각각의 HTTP 요청을 추적, 일부는 마이크로서비스 환경에서 분산 추적 핀포인트, 스카우트, 와탭, 제니퍼 등 로그 가장 자세한 추적 가능, 원하는대로 커스텀 가능 같은 HTTP 요청을 묶어서 확인할 수 있는 방법 중요 (MDC 적용) 각각 용도가 다르고, 관찰을 할 때는 전체에서 점점 좁게 보는 것이 좋다.\n모니터링 툴에서 일정 이상 수치가 넘어가면 슬랙 혹은 문자 등으로 알람을 주는 것이 좋으며, 이 때의 알람은 경고/심각 수준으로 구분해서 관리하는 것이 좋다.\n프로메테우스, 그라파나 모니터링 대시보드를 구축하기 위해서 프로메테우스와 그라파나를 설치하였다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 networks: common: driver: bridge prometheus: image: prom/prometheus container_name: prometheus volumes: - ./prometheus/config:/etc/prometheus - prometheus-data:/prometheus ports: - 9090:9090 command: - \u0026#39;--storage.tsdb.path=/prometheus\u0026#39; - \u0026#39;--config.file=/etc/prometheus/prometheus.yml\u0026#39; restart: always networks: - common grafana: image: grafana/grafana container_name: grafana ports: - 3000:3000 volumes: - grafana-data:/var/lib/grafana - ./grafana/provisioning/:/etc/grafana/provisioning/ restart: always depends_on: - prometheus networks: - common volumes: grafana-data: prometheus-data: 직접 관리하고 있는 Ubuntu 24.04 서버에 설치를 하였으며, 도커 컴포즈를 이용해 설치를 하였다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 # my global config global: scrape_interval: 15s # Set the scrape interval to every 15 seconds. Default is every 1 minute. evaluation_interval: 15s # Evaluate rules every 15 seconds. The default is every 1 minute. # scrape_timeout is set to the global default (10s). # Alertmanager configuration alerting: alertmanagers: - static_configs: - targets: # - alertmanager:9093 # Load rules once and periodically evaluate them according to the global \u0026#39;evaluation_interval\u0026#39;. rule_files: # - \u0026#34;first_rules.yml\u0026#34; # - \u0026#34;second_rules.yml\u0026#34; # A scrape configuration containing exactly one endpoint to scrape: # Here it\u0026#39;s Prometheus itself. scrape_configs: # The job name is added as a label `job=\u0026lt;job_name\u0026gt;` to any timeseries scraped from this config. - job_name: \u0026#34;prometheus\u0026#34; # metrics_path defaults to \u0026#39;/metrics\u0026#39; # scheme defaults to \u0026#39;http\u0026#39;. static_configs: - targets: [\u0026#34;localhost:9090\u0026#34;] - job_name: \u0026#34;mws-actuator\u0026#34; metrics_path: \u0026#39;/actuator/prometheus\u0026#39; scrape_interval: 10s static_configs: - targets: [\u0026#39;ip:8080\u0026#39;] 프로메테우스가 메트릭을 수집하여 저장을 해두고, 그라파나가 프로메테우스에 저장된 데이터를 가져와 보기 좋게 대시보드를 그려준다.\n여기서 메트릭을 수집하는 대상은 스프링 부트로 개발된 웹 애플리케이션이며, 스프링 엑추에이터와 마이크로미터를 사용하여 프로메테우스와 연동을 시켜주었다.\n1 2 sudo ufw allow 9090/tcp sudo ufw allow 3000/tcp 그리고 외부에서 접속할 수 있도록 방화벽에서 해당 포트를 풀어주었다.\n정상적으로 동작하는 것을 확인하였다. 다음에 여유가 될 때, 애플리케이션 추적과 클라우드에서 관리하는 로그 쪽을 다뤄볼 예정이다.\n","date":"2025-02-26T00:00:00Z","permalink":"https://dungbik.github.io/p/nb-til-8/","title":"내일배움캠프 - 8일차"},{"content":"ch.2 계산기 과제 트러블 슈팅 개요 정수만 받아서 계산하던 계산기를 실수도 받을 수 있게 계산하는데 단순히 int/long 에서 float/double로 바꾸는 것이 아닌 제네릭을 이용하여 리팩토링을 하는 과정에서 생겼던 문제를 다뤄보겠습니다.\n트러블 슈팅 배경 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class Calculator { /** * 피연산자 2개와 연산자를 계산하여 결과를 반환한다. * @param operand1 피연산자1 * @param operand2 피연산자2 * @param operation 연산자 * @return 계산한 결과 */ public Integer eval(int operand1, int operand2, char operation) { return switch (operation) { case \u0026#39;+\u0026#39; -\u0026gt; operand1 + operand2; case \u0026#39;-\u0026#39; -\u0026gt; operand1 - operand2; case \u0026#39;*\u0026#39; -\u0026gt; operand1 * operand2; case \u0026#39;/\u0026#39; -\u0026gt; { if (operand2 == 0) { yield null; } yield operand1 / operand2; } default -\u0026gt; throw new RuntimeException(\u0026#34;Unexpected operation: \u0026#34; + operation); }; } ... } 발단 정수만 받아서 계산하던 코드를 단순하게 제네릭으로 바꾸면 숫자를 연산할 수 없는 문제가 생깁니다.\n전개 해당 오류는 사칙연산은 숫자의 경우에만 연산이 가능한데 제네릭의 경우 숫자가 아닌 다른 형태를 가질 수 있기 때문에 발생합니다. 따라서 제네릭 T 가 항상 숫자임을 알려주고 연산을 하면 해결이 될 것 같아서 T에 타입을 나타낼 수 있는 방법이 있는지 찾아보고 적용해보았습니다.\n그 결과 아래의 코드로 해결을 하였습니다.\n결말 사칙연산은 숫자에만 연산이 가능하단 점을 생각하여, 제네릭에 숫자라는 것을 알려주면 해결될지 않을까? 라는 생각으로 해결을 하였습니다.\n마무리 이번 트러블 슈팅을 요약하면 다음과 같습니다.\n제네릭에 사칙연산과 같이 특정 타입에만 사용할 수 있는 것을 쓸 수 없습니다. 따라서 제네릭은 항상 숫자라는 것을 알려주면 해결이 될 것 같아 찾아보고 적용하였습니다. 적용한 내용이 정상적으로 동작이 되었습니다. ","date":"2025-02-25T00:00:00Z","permalink":"https://dungbik.github.io/p/nb-til-7/","title":"내일배움캠프 - 7일차"},{"content":"코드카타 LinkedList 끝에서 K번째 값 출력하기 LinkedList에서 Node가 Next Node만 알고 있다고 했을 때, 끝에서 K 번째 노드를 바로 찾을 수 없다. 따라서 LinkedList의 크기를 구하고, 그 크기에서 K a만큼 뺀 순서의 노드를 반환하도록 하였다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Node: def __init__(self, data): self.data = data self.next = None class LinkedList: def __init__(self, value): self.head = Node(value) def append(self, value): cur = self.head while cur.next is not None: cur = cur.next cur.next = Node(value) def get_kth_node_from_last(self, k): last_node = self.head size = 1 while last_node.next is not None: last_node = last_node.next size += 1 target_index = size - k result_node = self.head for i in range(target_index): result_node = result_node.next return result_node linked_list = LinkedList(6) linked_list.append(7) linked_list.append(8) print(linked_list.get_kth_node_from_last(2).data) 배달의 민족 배달 가능 여부 Q. 배달의 민족 서버 개발자로 입사했다. 상점에서 현재 가능한 메뉴가 [\u0026ldquo;떡볶이\u0026rdquo;, \u0026ldquo;만두\u0026rdquo;, \u0026ldquo;오뎅\u0026rdquo;, \u0026ldquo;사이다\u0026rdquo;, \u0026ldquo;콜라\u0026rdquo;] 일 때, 유저가 [\u0026ldquo;오뎅\u0026rdquo;, \u0026ldquo;콜라\u0026rdquo;, \u0026ldquo;만두\u0026rdquo;] 를 주문했다.\n그렇다면, 현재 주문 가능한 상태인지 여부를 반환하시오.\n단순하게 유저가 주문한 메뉴 문자열들이 가능한 메뉴에 포함되어 있는지만 확인하면 된다. 따라서 in 연산자 을 이용하면 된다.\n1 2 3 4 5 6 7 8 9 10 11 12 shop_menus = [\u0026#34;만두\u0026#34;, \u0026#34;떡볶이\u0026#34;, \u0026#34;오뎅\u0026#34;, \u0026#34;사이다\u0026#34;, \u0026#34;콜라\u0026#34;] shop_orders = [\u0026#34;오뎅\u0026#34;, \u0026#34;콜라\u0026#34;, \u0026#34;만두\u0026#34;] def is_available_to_order(menus, orders): menus_set = set(menus) for order in orders: if order not in menus_set: return False return True result = is_available_to_order(shop_menus, shop_orders) print(result) list 자료형 로 메뉴 목록을 받아왔는데 set 자료형 으로 바꾸었다. 그 이유는 파이썬은 내부에서 list에서 in 연산자 수행 시 O(N) 으로 동작하지만, set 은 O(1) 로 동작하기 때문이다.\n더하거나 빼거나 Q. 음이 아닌 정수들로 이루어진 배열이 있다. 이 수를 적절히 더하거나 빼서 특정한 숫자를 만들려고 한다. 예를 들어 [1, 1, 1, 1, 1]로 숫자 3을 만들기 위해서는 다음 다섯 방법을 쓸 수 있다.\n-1+1+1+1+1 = 3\n+1-1+1+1+1 = 3\n+1+1-1+1+1 = 3\n+1+1+1-1+1 = 3\n+1+1+1+1-1 = 3\n사용할 수 있는 숫자가 담긴 배열 numbers, 타겟 넘버 target_number이 매개변수로 주어질 때 숫자를 적절히 더하고 빼서 타겟 넘버를 만드는 방법의 수를 반환하시오.\n좋은 방법이 있나 생각을 해봤는데, 따로 떠오르는 방법이 없어서 브루트포스로 풀었다.\n더하거나 뺄 숫자가 하나 늘어날 때마다 기존의 경우들에서 + 혹은 - 를 하는 경우를 추가해주면 재귀적으로 구할 수 있다.\n예를 들어 아래와 같은 경우들이 있다고 가정을 하자.\n1 +1 -1 +1 1 -1 -1 -1 각 경우들에 새로 추가된 1을 더하거나 빼는 경우를 더하면 1이 3개 일 때 더하거나 빼는 모든 경우를 구할 수 있다.\n1 +1 1 +1 +1 1 +1 -1 -1 +1 -1 +1 +1 -1 +1 -1 1 -1 1 -1 +1 1 -1 -1 -1 -1 -1 -1 +1 -1 -1 -1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 numbers = [1, 1, 1, 1, 1] target_number = 3 def get_count_of_ways_to_target_by_doing_plus_or_minus(array, target): all_ways = [] def recur(array, current_index, current_sum): if current_index == len(array): all_ways.append(current_sum) return recur(array, current_index + 1, current_sum + array[current_index]) recur(array, current_index + 1, current_sum - array[current_index]) recur(array, 0, 0) target_count = 0 for way in all_ways: if target == way: target_count += 1 return target_count result = get_count_of_ways_to_target_by_doing_plus_or_minus(numbers, target_number) print(result) Git 협업 Branch branch: 브랜치 확인 브랜치이름: 브랜치 생성 -m 브랜치이름: 브랜치 이름 변경 -d 브랜치이름: 브랜치 삭제 switch 브랜치이름: 브랜치 이동 (new) -c 브랜치이름: 브랜치 생성 \u0026amp; 이동 checkout 브랜치이름: 브랜치 이동 (old) -b 브랜치이름: 브랜치 생성 \u0026amp; 이동 merge 브랜치이름: 브랜치 병합 Pull Request 코드 리뷰를 위해 사용한다. Confirm이 되면 자동으로 Merge 된다. 협업 실전 가이드 main / develop / feature branch를 사용하기 Pull Request를 통해 코드 리뷰 후 feature branch에서 develop branch로 병합하기 Pull Request에서 Reviewers랑 Assignees 지정하기 충돌시 로컬에서 해결 후 테스트하고 병합한다. ","date":"2025-02-24T00:00:00Z","permalink":"https://dungbik.github.io/p/nb-til-6/","title":"내일배움캠프 - 6일차"},{"content":"TIL (Today I Learned) 오늘 배운 것을 작성하는 것\n써야하는 이유 기성용 기록: 내가 무엇을 배웠는지 기록 성장: 학습한 것을 정리하며 이해도를 높이고 복습도 가능하다. 활용: 비슷한 문제 발생 시 활용할 수 있다. 취업: 현재 목표 취업을 위해서는 현재: 내가 남들보다 더 열심히 하고 잘한다는 것을 증명 해야 함 미래: 내가 남들보다 회사에 도움이 될 사람이라는 것을 증명 해야 함 면접관 입장 신입 개발자 -\u0026gt; 너무 몰라서 다 가르쳐야하는거 아니야? 프로젝트 -\u0026gt; 본인이 짠 코드가 맞을까?\n=\u0026gt; 신입이 가장 빠르게 경험과 실력을 증명하는 법 =\u0026gt; TIL 작성법 완벽 X 정답 X 하루에 한 번 일단 작성하기 쓰다 보면 더 잘 쓰고 싶은 생각이 들며, 그때 꼼꼼히, 제대로 작성하면 된다. 주제 정하기 : 오늘 배우고 느낀 것을 작성하면 된다. 강의 내용 정리하기 (초기) 오늘 배운 것은 무엇인가? 개념 정리 해당 개념이 필요한 이유 사용법 개발 단계 정리 하루 회고 일기처럼 편하게 작성한다. 오늘 있었던 일을 정리한다. 오늘 발생했던 일에 대한 느낀 점을 작성한다. 문제가 있었다면 앞으로 개선 방안을 정리한다. 문제 해결 과정 (권장) 발생한 문제(에러 및 버그)가 무엇인지 작성한다. 기존에 작성하려던 코드를 작성한다. 위 코드에서 문제점을 분석하고 가설을 세운다. 문제의 원인이 무엇이고 어떻게 해결했는지 작성한다. 문제 해결 과정 중 느낀점이 있으면 작성한다. TIL 부담 줄이는 법 공부, 프로젝트 진행 중 모든 생각과 과정을 동시에 기록하기 공부, 프로젝트 진행 중 대충 쓰고 나중에 정리 참고할만한 자료 개념 정리: https://velog.io/@alicia-mkkim/TlL-4-변수가-필요한-이유와-선언하는-방법 기능 개발 단계 정리: https://daeguowl.tistory.com/130 회고: https://leejincha.tistory.com/355 문제 해결 과정: https://daeguowl.tistory.com/171 일단 작성하기: https://wayhome25.github.io/ ","date":"2025-02-20T00:00:00Z","permalink":"https://dungbik.github.io/p/nb-til-4/","title":"내일배움캠프 - 4일차"},{"content":"Spring Transaction 선언적 트랜잭션 관리 vs 프로그래밍 방식의 트랜잭션 관리 선언적 트랜잭션 관리(Declarative Transaction Management)\n@Transactional 애너테이션 하나만 선언해서 편리하게 트랜잭션을 적용하는 것 프로그래밍 방식의 트랜잭션 관리(programmatic Transaction Management)\n트랜잭션 매니저 또는 트랜잭션 탬플릿 등을 사용해서 트랜잭션 관련 코드를 직접 작성하는 것 선언적 트랜잭션 관리 가 훨씬 간편하고 실용적이기 때문에 실무에서는 대부분 선언적 트랜잭션 관리 를 사용한다.\nSpring Boot Auto Configuration 1 2 3 4 5 6 7 8 9 @Bean DataSource dataSource() { return new DriverManagerDataSource(URL, USERNAME, PASSWORD); } @Bean PlatformTransactionManager transactionManager() { return new DataSourceTransactionManager(dataSource()); } 스프링 부트가 등장하기 이전에는 DataSource 와 TransactionManager 를 개발자가 직접 스프링 빈으로 등록해서 사용했다. (옛날에는 XML로 스프링 빈을 등록하고 관리했다.) 사용자가 등록한 빈은은 스프링 부트는 자동으로 등록하지 않는다. application.yml 또는 application.properties 에 있는 속성을 사용하는 경우도 있다. DataSource Auto Configuration 1 2 3 4 5 spring: datasource: url: jdbc:h2:tcp://localhost/~/tes username: sa password: 스프링 부트가 기본으로 생성하는 DataSource는 커넥션 풀을 제공하는 HikariDataSource 이다. spring.datasource.url 속성이 없으면 내장 데이터베이스(메모리 DB) 를 생성하려고 시도한다. Transaction Manager Auto Configuration 스프링 부트는 현재 등록된 라이브러리를 보고 적절한 트랜잭션 매니저를 자동으로 선택하여 스프링 빈에 등록한다. Exception 예외 계층 Error 메모리 부족이나 심각한 시스템 오류와 같이 애플리케이션이 복구 불가능한 시스템 예외이다. 개발자는 이 예외를 잡으려고 해서는 안된다. Exception 애플리케이션 로직에서 사용할 수 있는 실질적인 최상위 예외이다. Exception 과 그 하위 예외는 모두 컴파일러가 체크하는 체크 예외이다. 단 RuntimeException 은 예외로 한다. RuntimeException 컴파일러가 체크하지 않는 언체크 예외이다. 예외 기본 규칙 예외는 잡아서 처리하거나 던져야 한다. 예외를 잡거나 던질 때 지정한 예외뿐만 아니라 그 예외의 자식들도 함께 처리된다. 예외를 처리하지 못하고 계속 던지면 어떻게 될까? 자바 main() 쓰레드의 경우 예외 로그를 출력하면서 시스템이 종료된다. 웹 애플리케이션의 경우 여러 사용자의 요청을 처리하기 때문에 하나의 예외 때문에 시스템이 종료되면 안된다. WAS가 해당 예외를 받아서 처리하는데, 주로 사용자에게 개발자가 지정한 오류 페이지를 보여준다. 체크 예외, 언체크 예외 체크 예외 체크 예외는 잡아서 처리하거나 밖으로 던지도록 선언해야한다. 그렇지 않으면 컴파일러 오류가 발생한다. 1 2 3 4 5 try { } catch (Exception e) { } 체크 예외를 잡아서 처리하려면 try catch 문을 사용한다. catch 는 해당 타입과 그 하위 타입 모두 잡을 수 있다. 장점: 개발자가 실수로 예외를 누락하지 않도록 컴파일러를 통해 문제를 잡아주는 안전장치이다. 단점: 크게 신경쓰고 싶지 않은 예외까지 모두 챙겨야 한다. 추가로 의존관계에 따른 단점도 있다. 언체크 예외 컴파일러가 예외를 체크하지 않는다. 예외를 던지는 throw 예외 를 선언하지 않고 생략할 수 있다. 이 경우 자동으로 예외를 던진다. 장점: 신경쓰고 싶지 않은 언체크 예외를 무시할 수 있다. 추가로 의존관계를 참조하지 않아도 된다. 단점: 개발자가 실수로 예외 처리를 누락할 수 있다. 체크 예외 활용 기본적으로 언체크(런타임) 예외를 사용하자. 체크 예외는 비즈니스 로직상 의도적으로 던지는 예외에만 사용하자. 해당 예외를 잡아서 반드시 처리해야 하는 문제일 때만 사용해야 한다. ex) 계좌 이체 실패 예외 결제시 포인트 부족 예외 로그인 ID, PW 불일치 예외 물론 이 경우에도 100% 체크 예외로 만들어야 하는 것은 아니다. 다만 매우 심각한 문제는 개발자가 실수로 예외를 놓치면 안된다. 이 경우 체크 예외로 만들어두면 컴파일러를 통해 놓친 예외를 인지할 수 있다. 체크 예외의 문제점 Repository는 DB에 접근해서 데이터를 저장하고 관리한다. 여기서는 SQLException 체크 예외를 던진다. NetworkClient는 외부 네트워크에 접속해서 어떤 기능을 처리하는 객체이다. 여기서는 ConnectException 체크 예외를 던진다. Service는 Repository와 NetworkClient 둘 다 호출한다. Service는 SQLException 과 ConnectException 을 처리할 수 없으므로 둘 다 밖으로 던진다. ConnectException 처럼 연결이 실패하거나 SQLException 처럼 데이터베이스에서 발생하는 문제처럼 심각한 문제들은 대부분 애플리케이션 로직에서 처리할 방법이 없다. Controller도 두 예외를 처리할 방법이 없어서 밖으로 던진다. 웹 애플리케이션이라면 Servlet의 오류 페이지나 스프링 MVC가 제공하는 ControllerAdvice에서 이런 예외를 공통 처리한다. 이런 문제들은 보통 사용자에게 어떤 문제가 발생했는지 자세히 설명하기 어렵기 때문에 일반적인 오류 메시지를 보여준다. (자세히 알려주어도 사용자는 알 수 없고 보안에 문제가 될 수 있다.) API라면 보통 Internal Server Error 를 사용해서 응답을 내려준다. 이렇게 해결이 불가능한 공통 예외는 별도의 오류 로그를 남기고 개발자가 오류를 빨리 인지할 수 있도록 메일, 알림 등을 통해서 전달 받아야한다. SQLException 이 잘됫된 SQL을 작성해서 발생했다면 수정해서 배포하기 전까지 같은 문제가 계속 있다. 복구 불가능한 예외 심각한 문제들은 대부분 복구가 불가능하다. 특히나 대부분의 Service나 Controller에서는 이런 문제를 해결할 수 없다. 따라서 이런 문제들은 일관성 있게 공통으로 처리해야 한다. 오류 로그를 남기고 개발자가 해당 오류를 빠르게 인지하는 것이 필요하다. Servlet Filter, Spring Intercepter, Spring ControllerAdvice를 사용하면 이런 부분을 깔끔하게 공통으로 해결할 수 있다.\n의존 관계에 대한 문제 대부분의 예외는 복구 불가능한 예외이다. 그런데 체크 예외이기 때문에 Controller나 Service 입장에서는 처리할 수 없어도 어쩔 수 없이 throws 예외 를 통해 던지는 예외를 선언해야한다.\n1 2 3 4 5 6 7 8 9 10 11 class Controller { public void request() throws SQLException, ConnectException { service.logic(); } } class Service { public void logic() throws SQLException, ConnectException { repository.call(); networkClient.call(); } } Service, Controller 에서 SQLException 을 의존하기 때문에 문제가 된다.\n향후 Repository를 JDBC 기술이 아닌 다른 기술로 변경한다면 SQLException 에 의존하던 모든 Service, Controller의 코드를 수정해야한다. Service나 Controller 입장에서는 어차피 본인이 처리할 수도 없는 예외를 읜존해야 하는 큰 단점이 발생한다. 결과적으로 OCP, DI를 통해 클라이언트 코드의 변경없이 대상 구현체를 변경할 수 있다는 장점이 체크 예외 때문에 발목을 잡게 된다.\n1 void method() throws Exception {...} 이를 해결하려면 최상위 예외인 Exception을 던져도 문제를 해결할 수 있다. 하지만 다른 체크 예외를 체크할 수 있는 기능이 무효화되고, 중요한 체크 예외를 다 놓치게된다. 이렇게 하면 모든 예외를 다 던지기 때문에 체크 예외를 의도한대로 사용하는 것이 아니다. 따라서 꼭 필요한 경우가 아니면 쓰지 않는 것이 좋다.\n언체크 예외 활용 시스템에서 발생한 예외는 대부분 복구 불가능 예외이다. 런타임 예외를 사용하면 Service나 Controller가 이런 복구 불가능한 예외를 신경쓰지 않아도 된다. 물론 이렇게 복구 불가능한 예외는 일관성있게 공통으로 처리해야한다.\n런타임 예외는 해당 객체가 처리할 수 없는 예외는 무시하면 된다. 따라서 체크 예외처럼 강제로 의존하지 않아도 된다.\n런타임 예외는 문서화를 잘해야 한다. 또는 코드에 throws 런타임 예외 를 남겨서 중요한 예외를 인지할 수 있게 해준다.\n1 2 3 4 5 6 7 8 9 10 11 /** * Make an instance managed and persistent. * @param entity entity instance * @throws EntityExistsException if the entity already exists. * @throws IllegalArgumentException if the instance is not an * entity * @throws TransactionRequiredException if there is no transaction when * invoked on a container-managed entity manager of that is of type * \u0026lt;code\u0026gt;PersistenceContextType.TRANSACTION\u0026lt;/code\u0026gt; */ public void persist(Object entity); 1 2 3 4 5 6 /** * Issue a single SQL execute, typically a DDL statement. * @param sql static SQL to execute * @throws DataAccessException if there is any problem */ void execute(String sql) throws DataAccessException 예외 포함과 StackTrace 예외를 전환할 때는 꼭 기존 예외를 포함해야 한다. 그렇지 않으면 StackTrace를 확인할 때 심각한 문제가 발생한다.\n1 2 3 4 5 6 7 8 9 10 void printEx() { Controller controller = new Controller(); try { controller.request(); } catch (Exception e) { //e.printStackTrace(); // 실무에서 사용 X log.info(\u0026#34;ex\u0026#34;, e); // 로그에 StackTrace를 출력할 수 있다. } } 1 2 3 4 5 6 7 public void call() { try { runSQL(); } catch (SQLException e) { throw new RuntimeSQLException(e); // 기존 예외(e) 포함 } } 예외를 포함하지 않으면 기존에 발생한 예외와 StackTrace를 확인할 수 없어 원인을 알 수 없는 심각한 문제가 발생한다.\nSpring 예외 추상화 Spring은 데이터 접근 계층에 대한 수십 가지 예외를 정리해서 일관된 예외 계층을 제공한다. 각각의 예외는 특정 기술에 종속적이지 않게 설계되어있다. 따라서 Service 계층에서도 사용 가능하다. 기술에 종속적인 예외를 Spring이 제공하는 예외로 변환해주는 역할도 Spring이 제공한다. 크게 NonTransient 예외와 Transient 예외이다. Transient 예외들은 일시적으로 발생한 예외로 다시 시도했을 때 성공할 가능성이 있다. NonTransient 예외들은 일시적이지 않다는 뜻으로 다시 시도해도 실패한다. 예외 변환기 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Test void exceptionTranslator() { String sql = \u0026#34;select bad grammar\u0026#34;; try { Connection con = dataSource.getConnection(); PreparedStatement stmt = con.prepareStatement(sql); stmt.executeQuery(); } catch (SQLException e) { assertThat(e.getErrorCode()).isEqualTo(42122); //org.springframework.jdbc.support.sql-error-codes.xml SQLExceptionTranslator exTranslator = new SQLErrorCodeSQLExceptionTranslator(dataSource); //org.springframework.jdbc.BadSqlGrammarException DataAccessException resultEx = exTranslator.translate(\u0026#34;select\u0026#34;, sql, e); log.info(\u0026#34;resultEx\u0026#34;, resultEx); assertThat(resultEx.getClass()).isEqualTo(BadSqlGrammarException.class); } } Spring은 데이터베이스에서 발생한 오류 코드를 Spring이 정의한 예외로 자동으로 변환해주는 변환기를 제공한다. 변환할 때 아래의 org.springframework.jdbc.support.sql-error-codes.xml 파일을 이용한다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;bean id=\u0026#34;H2\u0026#34; class=\u0026#34;org.springframework.jdbc.support.SQLErrorCodes\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;badSqlGrammarCodes\u0026#34;\u0026gt; \u0026lt;value\u0026gt;42000,42001,42101,42102,42111,42112,42121,42122,42132\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;duplicateKeyCodes\u0026#34;\u0026gt; \u0026lt;value\u0026gt;23001,23505\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;MySQL\u0026#34; class=\u0026#34;org.springframework.jdbc.support.SQLErrorCodes\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;badSqlGrammarCodes\u0026#34;\u0026gt; \u0026lt;value\u0026gt;1054,1064,1146\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;duplicateKeyCodes\u0026#34;\u0026gt; \u0026lt;value\u0026gt;1062\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; Spring 예외 추상화 덕분에 특정 기술에 종속적이지 않게 되었다. 물론 Spring이 제공하는 예외를 사용하기 때문에 Spring에 대한 기술 종속성을 발생한다. Spring에 대한 기술 종속성까지 완전히 제거하려면 예외를 모두 직접 정의하고 예외 변환도 직접 하면 되지만, 실용적인 방법은 아니다. ","date":"2025-02-19T00:00:00Z","permalink":"https://dungbik.github.io/p/nb-til-3/","title":"내일배움캠프 - 3일차"},{"content":"Git, GitHub Git: 변경 내용을 추적하고 관리하는 분산 버전 관리(형상 관리) 시스템 GitHub: Git을 기반으로 하는 웹 호스팅 서비스 Git Workflow Git 명령어 init: 새로운 Git Repository를 생성 status: Local Repository의 상황을 확인 add: Working Directory 내의 변경 내용을 Staging Area에 추가 (기록할 변경 내용을 추가) commit: Staging Area에 올라온 변경 내용을 Local Repository에 기록 (추가된 변경 내용을 실제로 기록) log: Commit Log를 확인 reset: 과거의 Commit으로 이동 reflog: Local Repository에서 HEAD의 업데이트 기록을 확인 push: Local Repository의 변경 내용을 Remote Repository에 반영 remote -v: Git Remote Aliases 확인 add [alias] [url]: Git Remote Alias 추가 clone [url] [dir]: Remote Repository의 내용을 로컬에 복제 pull: Remote Repository의 변경 내용을 Local Repository에 반영 충돌 해결 git config pull.rebase false rebase를 하지 않도록 설정하여 merge를 수행한다.\nmerge를 수행하다 충돌이 발생하면 수동으로 충돌 부분을 수정하고 반영한다.\n충돌이 발생하는 이유 같은 파일의 같은 위치에 코드가 변경되었기 때문이다.\n미니 프로젝트 (팀 + 자기소개 웹페이지 만들기) 오늘부터 9 to 9 본 캠프가 시작되었다. 팀이 정해졌고 팀 이름, 소개를 정하고 역할 분담과 사용할 기술을 정하였으며 와이어프레임 설계까지 완료하였다. 메인/상세 페이지로 나눠지는 간단한 페이지를 개발할 예정이고, 상세 페이지 내에 들어가는 방명록 파트의 HTML을 작성하는 부분을 맡았다.\n","date":"2025-02-17T00:00:00Z","permalink":"https://dungbik.github.io/p/nb-til-1/","title":"내일배움캠프 - 1일차"},{"content":"Monolithic, Service-Oriented, Microservice Architecture Monolithic VS Service-Oriented 공통점 Shared DB를 사용한다. 원 코드 베이스 모듈/서비스 간 규격화된 호출 방식을 사용한다. 차이점 독립적으로 배포할 수 있다. 비지니스 로직에 따라 어떤 서비스를 호출할 지 결정하는 Layer(Enterprise Service Bus)가 존재한다. 트랜잭션 구현을 별개로 해줘야한다. 동일 플랫폼(JVM 환경)에서 서비스 간 호출을 하다보니 성능에 이슈가 존재한다. Service-Oriented VS Microservice 공통점 개발의 단위를 서비스 로 생각한다. 다른 서비스와 독립적으로 개발, 배포가 가능하다. 차이점 비지니스 로직(서비스)의 재사용을 지양한다. 서비스간 결합도록 낮추는 것이 목표다. 낮은 결합도로 변화에 애자일한 대응이 가능하다. 각 서비스는 각 서비스의 특성에 맞는 최적의 기술 스택을 독립적으로 선택 가능하다. 서비스 간 자유로운 방식으로 통신 가능하다. Microservice Architecture Business Capabilities 조직이 얼마나 빠르고 유연하게 변화에 대응할 수 있는지에 대한 능력 Monolithic, Service-Oriented 는 협업, 커뮤니케이션, 확장성, 유연성, 결합도, 응집도, 빌드와 배포 등의 문제로 해당 능력이 부족하다. ","date":"2025-02-14T00:00:00Z","permalink":"https://dungbik.github.io/p/nb-pre-til-21/","title":"사전캠프 21일차"},{"content":"트랜잭션(Transaction) 데이터베이스에 데이터를 저장하는 대표적인 이유는 트랜잭션이라는 개념을 지원하기 때문이다.\n예를 들어 A가 B한테 5,000원을 송금한다면 A의 잔액이 5000원 줄고, B의 잔액이 5000원 늘어나야한다. 이러한 거래는 2가지 작업은 하나의 작업처럼 동작해야한다. 한 작업은 성공하고 다른 작업은 실패했을 때 심각한 문제가 발생하기 때문이다.\n이럴 때 데이터베이스의 트랜잭션 기능을 사용하면 거래 중 문제가 발생하면 거래 이전으로 돌아갈 수 있다. 거래가 성공하여 데이터베이스에 정상 반영되는 것을 커밋(Commit), 하나라도 실패하여 이전으로 돌아가는 것을 롤백(Rollback) 이라고 한다.\n트랜잭션 ACID 트랜잭션 ACID라 하는 Atomicity(원자성), Consistency(일관성), Isolation(격리성), Durability(지속성) 을 보장해야한다.\n원자성: 트랜잭션 내에서 실행한 작업들은 마치 하나의 작업인 것처럼 모두 성공하든가 모두 실패해야 한다. 일관성: 모든 트랜잭션은 일관성 있는 데이터베이스 상태를 유지해야 한다. 격리성: 동시에 실행되는 트랜잭션들이 서로에게 영향을 미치지 않도록 격리한다. 지속성: 트랜잭션을 성공적으로 끝내면 그 결과가 항상 기록되어야 한다. 중간에 시스템에 문제가 발생해도 데이터베이스 로그 등을 사용해서 성공한 트랜잭션 내용을 복구해야 한다. 트랜잭션은 원자성, 일관성, 지속성을 보장한다. 문제는 격리성인데 트랙잭션간에 격리성을 완벽히 보장하려면 트랜잭션을 거의 차례대로 실행해야 한다. 이럴 경우 동시성 처리 성능이 매우 나빠지기 떄문에 ANSI 표준은 트랜잭션의 격리 수준(Isolation Level) 을 4단계로 나누어 정의했다.\n트랜잭션 격리 수준(Isolation Level) READ UNCOMMITED 의 격리 수준이 가장 낮고 SERIALIZABLE 의 격리 수준이 가장 높다.\n격리 수준이 낮을수록 동시성은 증가하지만 격리 수준에 따른 다양한 문제가 발생한다.\n트랜잭션 격리 수준과 문제점 격리 수준 DIRTY READ NON-REPEATABLE READ PHANTOM READ READ UNCOMMITED O O O READ COMMITED O O REPEATABLE READ O SERIALIZABLE READ UNCOMMITED: 커밋하지 않은 데이터를 읽을 수 있다. 예를 들어 데이터를 수정하고 있는데 커밋하지 않아도 수정 중인 데이터를 조회할 수 있다. 이것을 DIRTY READ 라고 한다. READ COMMITED: 커밋된 데이터를 읽을 수 있다. 따라서 DIRTY READ 가 발생하지 않는다. 하지만 트랜잭션 1이 회원 A를 조회 중인데 갑자기 트랜잭션 2가 회원 A를 수정하고 커밋하면 트랜잭션 1이 다시 회원 A를 조회했을 때 수정된 데이터가 조회된다. 이처럼 반복해서 같은 데이터를 읽을 수 없는 상태를 NON-REPEATABLE READ 라고 한다. REPEATABLE READ: 한 번 조회한 데이터를 반복해서 조회해도 같은 데이터가 조회된다. 하지만 트랜잭션 1이 10살 이하의 회원을 조회했을 때 회원 하나가 추가된 상태로 조회된다. 이처럼 반복 조회 시 결과 집합이 달라지는 것을 PHANTOM READ 라고 한다. SERIALIZABLE: 가장 엄격한 격리 수준으로, 이름 그대로 트랜잭션을 순차적으로 진행시킨다. 동시성 처리 성능이 급격히 떨어질 수 있다. 애플리케이션 대부분은 동시성 처리가 중요하므로 데이터베이스들은 보통 READ COMMITED 격리 수준을 기본으로 사용한다.\n트랜잭션 격리 수준에 따른 동작 방식은 데이터베이스마다 조금씩 다르다. 최근에는 데이터베이스들이 더 많은 동시성 처리를 위해 락보다는 MVCC(Multi-Version Concurrency Control)를 사용하므로 락을 사용하는 데이터베이스와 약간 다른 특성을 지닌다.\n데이터베이스 연결 구조와 세션 개발자가 클라이언트를 통해 SQL을 전달하면 현재 커넥션에 연결된 세션이 SQL을 실행한다. 세션은 트랜잭션을 시작하고, 커밋 또는 롤백을 통해 트랜잭션을 종료한다.\n자동 커밋, 수동 커밋 자동 커밋: 각각의 쿼리 실행 직후에 자동으로 커밋이 호출된다. 커밋 또는 롤백을 직접 호출하지 않아도 되는 편리함이 있지만 트랜잭션의 기능을 활용할 수 없다. 수동 커밋: 커밋을 호출하기 전까진 데이터가 임시로 저장된다. 따라서 같은 세션에서만 변경 데이터가 보인다. 세션 내에서 자동, 수동 커밋의 설정은 변경하기 전까지 유지된다.\n락(Lock) 데이터 변경 세션 1이 트랜잭션을 시작하고 데이터를 변경경하는 동안 커밋을 수행하지 않았는데, 세션 2에서 동시에 같은 데이터를 변경하게 되면 여러가지 문제가 발생한다. 바로 트랜잭션의 원자성이 깨지는 것이다. 여기에 더해서 세션 1이 중간에 롤백을 하게 되면 세션 2는 잘못된 데이터를 변경하는 문제가 발생한다.\n이런 문제를 방지하기 위해 세션이 트랜잭션을 시작하고 데이터를 변경하는 동안에 커밋이나 롤백 전까지 다른 세션에서 해당 데이터를 변경할 수 없도록 락(Lock) 이라는 개념을 제공한다.\n락(Lock) 을 획득해야 데이터의 변경이 가능하기 때문에 변경하려는 데이터가 다른 세션에서 변경 중인 경우 락(Lock) 이 돌아올 떄까지 대기하고 락 대기 시간을 넘어가면 락 타임 아웃 오류를 발생시킨다.\n데이터 조회 데이터베이스마다 다르지만 보통 데이터를 조회할 때는 락을 획득하지 않고 바로 조회할 수 있다.\n조회 시점에 락이 필요한 경우 트랜잭션 종료 시점까지 해당 데이터를 다른 곳에서 변경하지 못하도록 강제로 막아야할 때가 있다. 이런 경우 SELECT FOR UPDATE 구문을 사용하면 된다.\n낙관적 락과 비관적 락 낙관적 락: 트랜잭션 대부분은 충돌이 발생하지 않는다고 낙관적으로 가정하는 방법이다. 데이터베이스가 아닌 애플리케이션이 제공하는 락 기능을 사용한다. 대표적으로 JPA가 제공하는 버전 관리 기능이 있다 비관적 락: 트랜잭션의 충돌이 발생한다고 가정하고 우선 락을 걸고 보는 방법이다. 데이터베이스가 제공하는 락 기능을 사용한다. 대표적으로 SELECT FOR UPDATE 구문이 있다. 두 번의 갱신 분실 문제(Second Lost Updates Problem) A와 B가 동시에 같은 공지사항을 수정한다고 생각해보자. 둘이 동시에 수정 하면을 열어서 내용을 수정하는 중에 A가 먼저 수정완료 버튼을 눌렀다. 잠시 후에 B가 수정완료 버튼을 눌렀다. 결과적으로 먼저 수정된 A의 수정사항은 사라지고 B의 수정사항만 남게된다. 이것을 두 번의 갱신 분실 문제(Second Lost Updates Problem) 이라고 한다.\n이것은 트랜잭션만으로는 문제를 해결할 수 없다. 이 때는 3가지 선택 방법이 있다.\n마지막 커밋만 인정하기 최초 커밋만 인정하기 충돌하는 갱신 내용 병합하기 기본은 마지막 커밋만 인정하기가 사용된다. 하지만 상황에 따라 최초 커밋만 인정하기가 더 합리적일 수 있다. JPA가 제공하는 버전 관리 기능을 사용하면 손쉽게 최초 커밋만 인정하기를 구현할 수 있다.\n충돌하는 갱신 내용 병합하기는 최초 커밋만 인정하기를 조금 더 우아하게 처리하는 방법인데 애플리케이션 개발자가 직접 사용자를 위해 병합 방법을 제공해야 한다.\n모놀리스 아키텍처(Monolithic Architecture) 특징 하나의 주요 프로세스로 구성된다. 모든 서비스가 하나의 DB endpoint 를 사용한다. 단 한줄만 코드 수정이 되더라도, 모든 어플리케이션의 재배포가 필요하다. 싱글 혹은 멀티 모듈로 구성할 수는 있지만 CI(빌드)의 단위가 달라질 뿐, CD(배포)의 범위는 여전히 전체이다. 일반적으로 사용된 이유 고려할게 많지 않고 배포가 간단하다. 유지보수가 비교적 쉽다. 비싼 서버 자원의 효율적인 활용이 가능하다. 공통 모듈 등을 활용하기가 매우 쉽다. 싱글 모듈 모든 소스가 단일 모듈 내에 존재한다. 응집성 과 결합도 가 매우 높다. 설계/구현이 간단하고 단순하다. 유연성, 확장성 이 제한적이다. 멀티 모듈 역할, 서비스 별로 모듈화 되어 있다. 응집성 과 결합도 가 낮은 편이다. 모듈 간 인터페이스 정의가 필요하다. 유연성, 확장성 이 비교적 좋다. 단점 Scale Out 이 어렵다 시스템이 커질수록 커뮤니케이션 코스트가 기하급수적으로 늘어난다. 규모가 커질수록 복잡성이 증가하여 수정에 대한 부담이 늘어난다. 대규모 어플리케이션 환경에서는 단순한 수정 사항일지라도 배포까지 오래걸릴 수 있다. 장애 시 전체 애플리케이션에 영향을 크게 받는다. ","date":"2025-02-13T00:00:00Z","permalink":"https://dungbik.github.io/p/nb-pre-til-20/","title":"사전캠프 20일차"},{"content":"코드카타 작성 코드\n1번 - 2개 뽑아서 더하기, Lv. 1 2번 - H-Index, Lv. 2 3번 - 문자열 내 마음대로 정렬하기, Lv. 1 4번 - 가장 큰 수, Lv. 2 ","date":"2025-02-03T00:00:00Z","permalink":"https://dungbik.github.io/p/nb-pre-til-12/","title":"사전캠프 12일차"},{"content":"코드카타 작성 코드\n1번 - 모의고사, Lv. 1 2번 - 카펫, Lv. 2 3번 - 소수 찾기, Lv. 2 4번 - 불량 사용자, Lv. 3 5번 - 수식 최대화, Lv. 2 ","date":"2025-01-31T00:00:00Z","permalink":"https://dungbik.github.io/p/nb-pre-til-11/","title":"사전캠프 11일차"},{"content":"사전캠프 달리기반 Java 응용하기 Lv. 1 랜덤 닉네임 생성기 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package level1; import java.util.List; import java.util.Random; public class NicknameCreator { private final Random rand = new Random(); private final String[] firstValues = {\u0026#34;기철초풍\u0026#34;, \u0026#34;멋있는\u0026#34;, \u0026#34;재미있는\u0026#34;}; private final String[] secondValues = {\u0026#34;도전적인\u0026#34;, \u0026#34;노란색의\u0026#34;, \u0026#34;바보같은\u0026#34;}; private final String[] thirdValues = {\u0026#34;돌고래\u0026#34;, \u0026#34;개발자\u0026#34;, \u0026#34;오랑우탄\u0026#34;}; public String createNickname() { List\u0026lt;String\u0026gt; wordList = List.of(firstValues[rand.nextInt(firstValues.length)], secondValues[rand.nextInt(secondValues.length)], thirdValues[rand.nextInt(thirdValues.length)]); return String.join(\u0026#34; \u0026#34;, wordList); } public static void main(String[] args) { NicknameCreator nicknameCreator = new NicknameCreator(); String nickname = nicknameCreator.createNickname(); System.out.println(nickname); } } Lv2. 스파르타 자판기 1 2 3 4 5 6 7 8 9 10 11 package level2; public record Drink( String name, int price ) { @Override public String toString() { return String.format(\u0026#34;%s %s원\u0026#34;, name, NumberUtil.formatNumber(price)); } } 1 2 3 4 5 6 7 8 9 10 11 package level2; import java.text.DecimalFormat; public class NumberUtil { private static final DecimalFormat decFormat = new DecimalFormat(\u0026#34;###,###\u0026#34;); public static String formatNumber(int value) { return decFormat.format(value); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 package level2; import java.util.ArrayList; import java.util.List; import java.util.Scanner; public class VendingMachine { private List\u0026lt;Drink\u0026gt; drinks; public static void main(String[] args) { VendingMachine vm = new VendingMachine(); vm.initDrinkInfo(); vm.showDrinkInfo(); vm.startMachine(); } public void initDrinkInfo() { drinks = new ArrayList\u0026lt;\u0026gt;(); drinks.add(new Drink(\u0026#34;사이다\u0026#34;, 1700)); drinks.add(new Drink(\u0026#34;콜라\u0026#34;, 1900)); drinks.add(new Drink(\u0026#34;식혜\u0026#34;, 2500)); drinks.add(new Drink(\u0026#34;솔의눈\u0026#34;, 3000)); } public void showDrinkInfo() { drinks.forEach(System.out::println); } public Drink getDrink(String drinkName) { return drinks.stream() .filter(d -\u0026gt; d.name().equals(drinkName)) .findFirst() .orElse(null); } public void startMachine() { Scanner s = new Scanner(System.in); while (true) { System.out.print(\u0026#34;구매할 음료 : \u0026#34;); String name = s.nextLine(); if (name.isEmpty()) { if (s.hasNext()) { s.nextLine(); } continue; } Drink drink = getDrink(name); if (drink == null) { break; } System.out.print(\u0026#34;지불할 금액 : \u0026#34;); int price = s.nextInt(); if (price \u0026lt; drink.price()) { System.out.println(\u0026#34;돈이 부족합니다.\u0026#34;); continue; } String remainedMoney = NumberUtil.formatNumber(drink.price() - price); System.out.printf(\u0026#34;잔액 %s%n\u0026#34;, remainedMoney); } } } Lv3. 단어 맞추기 게임 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 package level3; import java.util.ArrayList; import java.util.List; import java.util.Random; import java.util.Scanner; public class WordGuessingGame { private static String[] words = {\u0026#34;airplane\u0026#34;, \u0026#34;apple\u0026#34;, \u0026#34;arm\u0026#34;, \u0026#34;bakery\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;bank\u0026#34;, \u0026#34;bean\u0026#34;, \u0026#34;belt\u0026#34;, \u0026#34;bicycle\u0026#34;, \u0026#34;biography\u0026#34;, \u0026#34;blackboard\u0026#34;, \u0026#34;boat\u0026#34;, \u0026#34;bowl\u0026#34;, \u0026#34;broccoli\u0026#34;, \u0026#34;bus\u0026#34;, \u0026#34;car\u0026#34;, \u0026#34;carrot\u0026#34;, \u0026#34;chair\u0026#34;, \u0026#34;cherry\u0026#34;, \u0026#34;cinema\u0026#34;, \u0026#34;class\u0026#34;, \u0026#34;classroom\u0026#34;, \u0026#34;cloud\u0026#34;, \u0026#34;coat\u0026#34;, \u0026#34;cucumber\u0026#34;, \u0026#34;desk\u0026#34;, \u0026#34;dictionary\u0026#34;, \u0026#34;dress\u0026#34;, \u0026#34;ear\u0026#34;, \u0026#34;eye\u0026#34;, \u0026#34;fog\u0026#34;, \u0026#34;foot\u0026#34;, \u0026#34;fork\u0026#34;, \u0026#34;fruits\u0026#34;, \u0026#34;hail\u0026#34;, \u0026#34;hand\u0026#34;, \u0026#34;head\u0026#34;, \u0026#34;helicopter\u0026#34;, \u0026#34;hospital\u0026#34;, \u0026#34;ice\u0026#34;, \u0026#34;jacket\u0026#34;, \u0026#34;kettle\u0026#34;, \u0026#34;knife\u0026#34;, \u0026#34;leg\u0026#34;, \u0026#34;lettuce\u0026#34;, \u0026#34;library\u0026#34;, \u0026#34;magazine\u0026#34;, \u0026#34;mango\u0026#34;, \u0026#34;melon\u0026#34;, \u0026#34;motorcycle\u0026#34;, \u0026#34;mouth\u0026#34;, \u0026#34;newspaper\u0026#34;, \u0026#34;nose\u0026#34;, \u0026#34;notebook\u0026#34;, \u0026#34;novel\u0026#34;, \u0026#34;onion\u0026#34;, \u0026#34;orange\u0026#34;, \u0026#34;peach\u0026#34;, \u0026#34;pharmacy\u0026#34;, \u0026#34;pineapple\u0026#34;, \u0026#34;plate\u0026#34;, \u0026#34;pot\u0026#34;, \u0026#34;potato\u0026#34;, \u0026#34;rain\u0026#34;, \u0026#34;shirt\u0026#34;, \u0026#34;shoe\u0026#34;, \u0026#34;shop\u0026#34;, \u0026#34;sink\u0026#34;, \u0026#34;skateboard\u0026#34;, \u0026#34;ski\u0026#34;, \u0026#34;skirt\u0026#34;, \u0026#34;sky\u0026#34;, \u0026#34;snow\u0026#34;, \u0026#34;sock\u0026#34;, \u0026#34;spinach\u0026#34;, \u0026#34;spoon\u0026#34;, \u0026#34;stationary\u0026#34;, \u0026#34;stomach\u0026#34;, \u0026#34;strawberry\u0026#34;, \u0026#34;student\u0026#34;, \u0026#34;sun\u0026#34;, \u0026#34;supermarket\u0026#34;, \u0026#34;sweater\u0026#34;, \u0026#34;teacher\u0026#34;, \u0026#34;thunderstorm\u0026#34;, \u0026#34;tomato\u0026#34;, \u0026#34;trousers\u0026#34;, \u0026#34;truck\u0026#34;, \u0026#34;vegetables\u0026#34;, \u0026#34;vehicles\u0026#34;, \u0026#34;watermelon\u0026#34;, \u0026#34;wind\u0026#34;}; public static void main(String[] args) { Scanner sc = new Scanner(System.in); Random rand = new Random(); String selectedWord = words[rand.nextInt(words.length)]; StringBuilder inputWord = new StringBuilder(\u0026#34;_\u0026#34;.repeat(selectedWord.length())); List\u0026lt;String\u0026gt; usedChars = new ArrayList\u0026lt;\u0026gt;(); System.out.println(inputWord); for (int retry = 0; retry \u0026lt; 9; retry++) { String input = sc.nextLine(); while (input.length() != 1 || !input.matches(\u0026#34;^[a-zA-Z]*$\u0026#34;) || usedChars.contains(input)) { input = sc.nextLine(); } usedChars.add(input); if (selectedWord.contains(input)) { for (int i = 0; i \u0026lt; selectedWord.length(); i++) { if (selectedWord.charAt(i) == input.charAt(0)) { inputWord.setCharAt(i, input.charAt(0)); } } } System.out.println(inputWord); if (inputWord.toString().equals(selectedWord)) { System.out.println(\u0026#34;플레이어의 승리\u0026#34;); break; } } } } 코드카타 1번 - 모음사전, Lv. 2 2번 - 호텔 방 배정, Lv. 4 ","date":"2025-01-24T00:00:00Z","permalink":"https://dungbik.github.io/p/nb-pre-til-10/","title":"사전캠프 10일차"},{"content":"Firebase 구글(Google)이 개발한 모바일 및 웹 애플리케이션 개발 플랫폼입니다. 개발자들이 백엔드 인프라를 구축하거나 관리하는 복잡한 작업 없이 핵심 기능에 집중할 수 있도록 도와줍니다.\n데이터베이스 데이터를 저장하고 여러 사람들이 관리하는 데이터의 모음 정보를 쉽게 찾고 업데이트할 수 있고, 많은 양의 정보를 효율적으로 관리할 수 있음 관계형 데이터베이스 (SQL) 정리된 정보를 다룰 떄 사용\n비관계형 데이터베이스 (NoSQL) 복잡하거나 유연한 정보를 다룰 때 사\nFirebase Database 구글의 클라우드 기반 NoSQL 데이터베이스\n구성 Collection: 여러 개의 문서들을 그룹화 시키는 특정한 주제 또는 유형 Document: 여러 개의 Field가 모여있는 문서 Field: 문서 안에 들어 있는 데이터\nGithub 인터넷에서 개발자들이 자신의 코드를 저장하고 다른 사람들과 공유하는 곳 분산 버전 관리 툴인 깃(Git)를 사용하는 프로젝트를 지원하는 웹호스팅 서비스이다. 주요 기능 코드 관리 협업 정적 웹 호스팅 (Github Pages) 지식 공유 Git 형상 관리 도구 중 하나로, 컴퓨터 파일의 변경사항을 추적하고 여러 명의 사용자들 간에 해당 파일들의 작업을 조율하기 위한 분산 버전 관리 시스템\n코드카타 1번 - 콜라츠 추측, Lv. 1 2번 - 하노이의 탑, Lv. 3 ","date":"2025-01-22T00:00:00Z","permalink":"https://dungbik.github.io/p/nb-pre-til-8/","title":"사전캠프 8일차"},{"content":"웹의 동작 브라우저의 역할은 서버에 GET 요청을 보내고 받은 (HTML + CSS + JavaScript)를 읽고 그려주는 것\nHTML 웹페이지의 뼈대를 담당하는 마크업 언어\nCSS HTML을 통해 작성된 뼈대를 예쁘게 꾸며주는 코드\nJavaScript 웹페이지의 동적인 기능을 구현하기 위해 사용되는 코드\nJQuery JavaScript 라이브러리로 HTML의 요소들을 조작하는 기능을 더욱 쉽게 사용하기 위한 것\nFetch 브라우저에서 제공하는 JavaScript API로 서버와 비동기적으로 데이터를 주고 받을 때 사용함\n코드카타 1번 - 3진법 뒤집기, Lv. 1 2번 - 이진 변환 반복하기, Lv. 2 3번 - 신규 아이디 추천, Lv. 1 4번 - 문자열 다루기 기본, Lv. 1 5번 - 핸드폰 번호 가리기, Lv. 1 ","date":"2025-01-21T00:00:00Z","permalink":"https://dungbik.github.io/p/nb-pre-til-7/","title":"사전캠프 7일차"},{"content":"Subquery 여러 번의 연산을 한 번의 SQL 문으로 수행할 때 사용한다.\n필요한 경우 여러 번의 연산을 수행할 떄 조건문에 연산 결과를 사용할 떄 조건에 Query 결과를 사용하고 싶을 때 기본 구조 1 2 3 4 5 6 select column1, special_column from ( /* subquery */ select column1, column2 special_column from table1 ) a Join 필요한 데이터가 서로 다른 테이블에 있을 때 조회하기 위해 사용한다.\n기본 원리와 종류 공통 컬럼을 기준으로 두 테이블을 합쳐서, 각각 테이블에서 필요한 데이터를 조회할 수 있다. LEFT JOIN: 공통 컬럼을 기준으로, 하나의 테이블에 값이 없더라도 모두 조회 INNER JOIN: 공통 컬럼을 기준으로, 두 테이블에 모두에 있는 값만 조회 기본 구조 1 2 3 4 5 6 7 -- LEFT JOIN select 조회 할 컬럼 from 테이블1 a left join 테이블2 b on a.공통컬럼명=b.공통컬럼명 -- INNER JOIN select 조회 할 컬럼 from 테이블1 a inner join 테이블2 b on a.공통컬럼명=b.공통컬럼명 공통 컬럼의 이름은 같을 필요가 없다. 조회한 데이터에 값이 없다면 없는 값을 제외하기 1 2 3 4 5 select restaurant_name, avg(rating) average_of_rating, avg(if(rating\u0026lt;\u0026gt;\u0026#39;Not given\u0026#39;, rating, null)) average_of_rating2 from food_orders group by 1 1 2 3 4 5 6 7 8 9 select a.order_id, a.customer_id, a.restaurant_name, a.price, b.name, b.age, b.gender from food_orders a left join customers b on a.customer_id=b.customer_id where b.customer_id is not null 다른 값을 대신 사용하기 데이터 분석의 경우 평균 값 혹은 중앙 값등을 대표 값으로 대체해주기도 함 방법 다른 값이 있을 때 조건문 이용하기 : if(rating\u0026gt;=1, rating, 대체값) null 값일 때 : coalesce(age, 대체값) 조회한 데이터가 상식적이지 않은 값이라면 조건문으로 값의 범위를 지정\n1 2 3 4 5 select customer_id, name, email, gender, age, case when age\u0026lt;15 then 15 when age\u0026gt;80 then 80 else age end \u0026#34;범위를 지정해준 age\u0026#34; from customers SQL로 Pivot Table 만들어보기 Pivot Table: 2개 이상의 기준으로 데이터를 집계할 떄, 보기 쉽게 배열하여 보여주는 실제 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 select restaurant_name, max(if(hh=\u0026#39;15\u0026#39;, cnt_order, 0)) \u0026#34;15\u0026#34;, max(if(hh=\u0026#39;16\u0026#39;, cnt_order, 0)) \u0026#34;16\u0026#34;, max(if(hh=\u0026#39;17\u0026#39;, cnt_order, 0)) \u0026#34;17\u0026#34;, max(if(hh=\u0026#39;18\u0026#39;, cnt_order, 0)) \u0026#34;18\u0026#34;, max(if(hh=\u0026#39;19\u0026#39;, cnt_order, 0)) \u0026#34;19\u0026#34;, max(if(hh=\u0026#39;20\u0026#39;, cnt_order, 0)) \u0026#34;20\u0026#34; from ( select a.restaurant_name, substring(b.time, 1, 2) hh, count(1) cnt_order from food_orders a inner join payments b on a.order_id=b.order_id where substring(b.time, 1, 2) between 15 and 20 group by 1, 2 ) a group by 1 order by 7 desc Window Function - RANK, SUM 기본 구조 1 window_function(argument) over (partition by 그룹 기준 컬럼 order by 정렬 기준) RANK 특정 기준으로 순위를 매겨주는 기능 예시 (음식 타입별로 주문 건수가 가장 많은 상점 3개씩 조회하기)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 select cuisine_type, restaurant_name, order_count, rn \u0026#34;순위\u0026#34; from ( select cuisine_type, restaurant_name, rank() over (partition by cuisine_type order by order_count desc) rn, order_count from ( select cuisine_type, restaurant_name, count(1) order_count from food_orders group by 1, 2 ) a ) b where rn\u0026lt;=3 order by 1, 4 SUM 합계를 구하는 기능 누적 합이 필요하거나 카테고리별 합계 컬럼과 원본 컬럼을 함께 이용할 떄 유용함 예시(각 음식점의 주문건이 해당 음식 타입에서 차지하는 비율을 구하고, 주문건이 낮은 순으로 정렬했을 때 누적 합 구하기)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 select cuisine_type, restaurant_name, cnt_order, sum(cnt_order) over (partition by cuisine_type) sum_cuisine, sum(cnt_order) over (partition by cuisine_type order by cnt_order) cum_cuisine from ( select cuisine_type, restaurant_name, count(1) cnt_order from food_orders group by 1, 2 ) a order by cuisine_type , cnt_order 포맷 함수 날짜 데이터 년, 월, 일, 시, 분, 초 등의 값을 모두 갖고 있으며 목적에 따라 ‘월’, ‘주’, ‘일’ 등으로 포맷을 변경할 수도 있습니다.\n여러 포맷 년 : Y (4자리), y(2자리) 월 : M, m 일 : d, e 요일 : w 1 2 3 4 5 6 select date(date) date_type, date_format(date(date), \u0026#39;%Y\u0026#39;) \u0026#34;년\u0026#34;, date_format(date(date), \u0026#39;%m\u0026#39;) \u0026#34;월\u0026#34;, date_format(date(date), \u0026#39;%d\u0026#39;) \u0026#34;일\u0026#34;, date_format(date(date), \u0026#39;%w\u0026#39;) \u0026#34;요일\u0026#34; from payments 예시(3월 조건으로 지정하고, 년도별로 주문건수 정렬하기)\n1 2 3 4 5 6 7 8 select date_format(date(date), \u0026#39;%Y\u0026#39;) \u0026#34;년\u0026#34;, date_format(date(date), \u0026#39;%m\u0026#39;) \u0026#34;월\u0026#34;, date_format(date(data), \u0026#39;Y%m\u0026#39;) \u0026#34;년월\u0026#34;, count(1) \u0026#34;주문건수\u0026#34; from food_orders a inner join payments b on a.order_id=b.order_id where date_format(date(date), \u0026#39;%m\u0026#39;)=\u0026#39;03\u0026#39; group by 1, 2 order by 1 코드카타 1번 - 짝지어 제거하기, Lv.2 2번 - 문자열 압축, Lv. 2 ","date":"2025-01-20T00:00:00Z","permalink":"https://dungbik.github.io/p/nb-pre-til-6/","title":"사전캠프 6일차"},{"content":" 내가 Spring 트랙에 참여한 계기는 무엇인가요? 다양한 사람들과 프로젝트를 하고싶어서 내가 이해한 개발자(혹은 생각했던 직무)는 어떤 역할을 하는 사람인가요? 사용자에게 좋은 서비스를 제공하는 프로그램을 개발하는 사람 프로그래밍을 경험해보셨나요? 해보셨다면 어떤 경험을 하셨는지를 작성해주시고, 아니라면 프로그래밍/백엔드 개발에 대해 찾아본 것을 작성해주세요. 학부생, 연구실 연구원 시절 C++, Java, Python 등을 활용해 키워드 기반 상품 추천 서비스, 눈 깜빡임을 인식하는 어플, 바이오 정보 분석 도구 등을 개발했습니다. 대외 활동 및 해커톤에서 온라인 저지 서비스, 인공지능을 활용한 교과목 추천 서비스, VR을 이용한 화학 실험 등을 개발했습니다. 임베디드 개발자로 일하면서 C++과 JavaScript를 활용해 빅데이터 가공 및 모니터링 서버와 스마트 팩토리 서버, 양자 통신 서비스 등을 개발했습니다. 백엔드 개발자로 일하면서 블록체인 서비스를 개발하였습니다. 개발자의 역할을 수행하는 데에 있어 나의 강점과 연관된 부분은 무엇이라고 생각하나요? 혹은 보완, 개선하고 싶은 개인 역량이 있나요 ? 과거 혹은 현재의 업무와 연관 지어도 좋습니다. ‘능력’을 기준으로 고민해주세요. 현재에 만족하지 않고 항상 앞으로 나아가려는 강점이 있습니다. 이를 통해 항상 더 나은 방법 효율적인 방법을 찾기 위해 노력합니다. 본 코스 수료 후, 어떤 개발자(혹은 생각했던 직무)로 성장하고 싶나요? 쾌적한 서비스 이용 경험을 제공할 수 있는 개발자 단순히 기술을 사용하는 것이 아닌 선택한 이유와 결과가 확실히 나오게 하는 개발자 본 코스 수료 후, 개발자(혹은 생각했던 직무)가 된 5년 후 목표로하는 점은 무엇인가요? 단순히 서버(백엔드) 뿐만 아닌 풀스택을 목표로 하고 있습니다. ","date":"2025-01-13T00:00:00Z","permalink":"https://dungbik.github.io/p/nb-starter-note/","title":"내일배움캠프 - 스타터 노트"},{"content":"안녕하세요, 2년차 서버 개발자 윤정환(Dungbik) 입니다.\nSkills Java, Python, JavaScript Spring Boot, JPA, FastAPI, Flask, Express, NestJS MySQL, MongoDB, Redis, Kafka, RabbitMQ Career 휴라 (2021.02 ~ 2021.07) 임베디드 개발 포스트보이저 (2022.04 ~ 2023.05) 블록체인 서비스 서버 개발 ","date":"2025-01-02T00:00:00Z","permalink":"https://dungbik.github.io/p/about-me/","title":"About Me"}]